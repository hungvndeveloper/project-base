- Node.js treats each file in a Node project as a module that can export values and functions from the file.
- Declare Objects with const
        - Declaring objects with const will prevent any accidental change of type:
            let car = {type:"Fiat", model:"500", color:"white"};
            car = "Fiat";      // Changes object to string

            const car = {type:"Fiat", model:"500", color:"white"};
            car = "Fiat";      // Not possible
            car.newProperty = "newValue"; // it's ok
            car['newProperty1'] = "newValue1"; // it's ok
    - Declare Arrays with const:
        - Declaring arrays with const will prevent any accidential change of type:
            let cars = ["Saab", "Volvo", "BMW"];
            cars = 3;    // Changes array to number

            const cars = ["Saab", "Volvo", "BMW"];
            cars = 3;    // Not possible
            cars.push("newValue") // It's ok
            cars[4] = "Toyota"; // It's ok
#############################################
- Comparison table for CommonJS and ES Modules
    - Module Loading:
        - CommonJS: Synchronous
        - ES Module: Asynchronous
    - Import/Export:
        - CommonJS: 'require'/'exports'
        - ES Module: 'import'/'export'
    - Caching
        - CommonJS: Cached
        - ES Module: Not cached by default
    - Use Case
        - CommonJS: Server-side
        - ES Module: Client-side and server-side
    - Dynamic Import
        - CommonJS: Not supported
        - ES Module: Supported
Node.js module.exports vs. exports. Ã¡p dá»¥ng náº¿u sá»­ dá»¥ng CommonJS
    - exports vÃ  module.exports chá»© khÃ´ng pháº£i lÃ  export nhÃ© cÃ¡c báº¡n, export lÃ  cho bÃªn ES module.
      Nhiá»u báº¡n hay viáº¿t thiáº¿u chá»¯ â€œsâ€ láº¯m áº¥y.
      Trong Javascript thÃ¬ cÃ³ cÃ¡i tá»« khÃ³a export nhÆ°ng trong NodeJS thÃ¬ chÆ°a Ä‘Ã¢u.
    - Furthermore, you will come across three types of modules in Node.js:
        - Core Modules: These are built-in modules like http, fs, etc.
        - Local Modules: These modules are locally created by the programmer.
        - Third-Party Modules: These modules are available to use after installation
          using NPM(Node Package Manager) like: express, mongoose etc.
    - CÆ¡ cháº¿ Wrapping cá»§a NodeJS lÃ  gÃ¬?
        - When we call require in our application, the new module is created.
          Its initial value is an empty object literal {}. Before the referenced moduleâ€™s code
          is executed, Node.js will wrap it with the module wrapper function. 
          Let's look briefly into the structure of the module wrapper function:
            (function(exports, require, module, __filename, __dirname) { 
                // Module code actually lives in here 
            });
        - Using the module wrapper function, Node.js keeps top-level variables
          (defined with var, const, or let) scoped to the module rather than as the global
          object. It also provides access to the exported module-specific variables for use
          in our application.
        - The variables __filename and __dirname in the module wrapper function contain the
          absolute filename and directory path of the module.
        - Now let's look into module.exports, module.exports is the object reference that gets
          returned when we make require() calls in our application. By module. exports,
          we can get access to module-specific variables that donâ€™t leak out to the global object.
    - module.exports vÃ  exports khÃ¡c nhau nhÆ° tháº¿ nÃ o?
        - TrÆ°á»›c háº¿t thÃ¬ module.exports vÃ  exports trá» tá»›i cÃ¹ng má»™t Object, lÃ  má»™t Object rá»—ng.
        - Tuy nhiÃªn, chá»‰ cÃ³ má»™t tháº±ng module.exports lÃ  cÃ¡i tháº­t sá»± Ä‘Æ°á»£c export khi mÃ¬nh require nÃ³ thÃ´i. 
          CÃ²n tháº±ng exports thÃ¬ khÃ´ng pháº£i. NÃ³ chá»‰ lÃ  má»™t reference tá»›i tháº±ng module.exports thÃ´i.
            - vÃ­ dá»¥:
                module.exports.name = "Nguyen";
                exports.name = "Nguyen";
                console.log(module.exports); //{ name: 'Nguyen' }
                console.log(exports); //{ name: 'Nguyen' }
                console.log(module.exports === exports); //true
            - á»ž Ä‘Ã¢y cÃ³ thá»ƒ tháº¥y hai tháº±ng nÃ y chá»‰ thay Ä‘á»•i cÃ¡i properties cá»§a cÃ¡i Object ban Ä‘áº§u
              (lÃ  Object rá»—ng ban Ä‘áº§u). NÃªn á»Ÿ Ä‘Ã¢y, hai tháº±ng nÃ y váº«n lÃ  cÃ¹ng má»™t Object.
            - Tuy nhiÃªn, náº¿u nhÆ° sá»­a láº¡i:
                module.exports = {
                    name: "Nguyen"
                };
                exports = {
                    name: "Nguyen"
                };
                console.log(module.exports === exports); // false
            - Hai tháº±ng nÃ y lÃ  hai cÃ¡i Object khÃ¡c nhau, vÃ¬ mÃ¬nh lÃ  assign láº¡i giÃ¡ trá»‹ cho tháº±ng
              exports (MÃ¬nh dÃ¹ng dáº¥u =).Káº¿t quáº£ sáº½ lÃ  false
            - MÃ¬nh chá»©ng minh thÃªm nhÆ° sau:
                - Trong file export.js mÃ¬nh viáº¿t: 
                    exports = {
                        name: "Nguyen"
                    };
                - Sau Ä‘Ã³, trong file index.js mÃ¬nh viáº¿t
                    const object = require("./export");
                    console.log(object);
                - ThÃ¬ káº¿t quáº£ lÃ  {}
            - VÃ¬ chá»‰ lÃ  tháº±ng module.exports má»›i lÃ  tháº±ng tháº­t sá»± Ä‘Æ°á»£c export
              (VÃ  máº·c Ä‘á»‹nh nÃ³ lÃ  má»™t Object rá»—ng). CÃ²n tháº±ng exports thÃ¬ khÃ´ng.
        - Váº­y thÃ¬ khi nÃ o sá»­ dá»¥ng tháº±ng exports?
            - DÃ¹ng tháº±ng exports chá»‰ khi nÃ o mÃ¬nh muá»‘n add thÃªm má»™t cÃ¡i properties vÃ o
              cÃ¡i Object máº·c Ä‘á»‹nh cá»§a nÃ³. VÃ­ dá»¥ nhÆ° thay vÃ¬ viáº¿t;
                module.exports.x = 1;
                module.exports.y = 2;
                module.exports.z = 3;
            - ThÃ¬ cÃ³ thá»ƒ viáº¿t thÃ nh nhÆ° sau cho nÃ³ ngáº¯n vÃ  tiá»‡n hÆ¡n.
                exports.x = 1;
                exports.y = 2;
                exports.z = 3;
    - Káº¿t luáº­n:
        - LuÃ´n sá»­ dá»¥ng module.exports khi muá»‘n export má»™t cÃ¡i gÃ¬ Ä‘Ã³.
          Äá»«ng lÄƒn tÄƒn sá»­ dá»¥ng exports lÃ  gÃ¬ cho rá»‘i ráº¯m háº¿t cáº£ lÃªn.  
##################################
JavaScript Object Rest Properties
    - ECMAScript 2018 added rest properties.
    - This allows us to destruct an object and collect the leftovers onto a new object:
        Example
            let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
            x; // 1
            y; // 2
            z; // { a: 3, b: 4 }
############################################
Arguments javascript dá»… hiá»ƒu mÃ  sao há» giáº£i thÃ­ch dÃ i tháº¿
    - Tháº­t ra nÃ³ ráº¥t dá»… hiá»ƒu, viá»‡c thÃ´ng qua nhá»¯ng vÃ­ dá»¥ dÆ°á»›i Ä‘Ã¢y lÃ  hiá»ƒu rá»“i. 
      NhÆ°ng Ä‘áº¿n giá» tÃ´i khÃ´ng biáº¿t táº¡i sao cÃ³ nhiá»u bÃ i viáº¿t giáº£i thÃ­ch dÃ i dÃ²ng Ä‘áº¿n nhÆ° váº­y. HÃ£y xem vÃ­ dá»¥:
        function add (num1, num2) {
            // logs [num1, num2] (with their values)
            console.log(arguments); [num1, num2]
            // Láº¥y ra param Ä‘áº§u tiÃªn 
            console.log(arguments[0]); // num1
            // Láº¥y ra param thá»© 2
            console.log(arguments[1]); // num2
            // ...
        }
    - VÃ­ dá»¥ nÃ y chÃºng tÃ´i táº¡o má»™t Regular Function. Äá»«ng nÃ³i vá»›i tÃ´i Regular Function lÃ  gÃ¬? Ä‘áº¥y nhÃ©. Váº­y thÃ´i Ä‘Æ¡n giáº£n gá»n nháº¹,
      arguments giÃºp chÃºng ta láº¥y Ä‘Æ°á»£c tham sá»‘ truyá»n vÃ o má»™t cÃ¡ch dá»… dÃ ng. á»ž Ä‘Ã¢y cÃ³ Ã½ kiáº¿n cho ráº±ng váº­y "khÃ¡c gÃ¬ cÃ¡ch láº¥y tham sá»‘ Ä‘Ã¢u?" 
    - OK, vÃ­ dá»¥ tiáº¿p theo sáº½ khÃ¡c Ä‘áº¥y.
        function add () {
            // Set biáº¿n tá»•ng
            let total = 0;
            // Cá»™ng Ä‘á»“n má»—i params
            Array.from(arguments).forEach(function (num) {
                total += num;
            });
            // Return to the total
            return total;
        }
    - Tiáº¿p theo chÃºng ta sá»­ dá»¥ng vÃ­ dá»¥ nÃ y nhÆ° sau:
        // returns 0
        add();
        // returns 4
        add(4);
        // returns 36
        add(4, 2, 11, 19);
    - CÃ³ gÃ¬ khÃ¡c chÆ°a? KhÃ¡c Ä‘Ãºng khÃ´ng? Äiá»u nÃ y Ä‘áº·c biá»‡t há»¯u Ã­ch náº¿u báº¡n muá»‘n cho phÃ©p má»™t sá»‘ lÆ°á»£ng khÃ´ng giá»›i háº¡n cÃ¡c Ä‘á»‘i sá»‘ Ä‘Æ°á»£c chuyá»ƒn vÃ o hÃ m cá»§a báº¡n.
    - Arguments javascript sá»­ dá»¥ng nÃªn chÃº Ã½
    - Khi sá»­ dá»¥ng Arguments trong javascript cÅ©ng nÃªn chÃº Ã½ má»™t Ä‘iá»u cÅ©ng hÆ¡i quan trá»ng Ä‘Ã³ lÃ  arguments
      giá»‘ng nhÆ° má»™t Array nhÆ°ng nÃ³ khÃ´ng thá»±c sá»± lÃ  má»™t Array. Náº¿u nÃ³ lÃ  má»™t Array thÃ¬ táº¥t cáº£ 10 method cá»§a Array Ä‘á»u cÃ³ thá»ƒ sá»­ dá»¥ng Ä‘Æ°á»£c. 

    - NhÆ°ng vÃ­ dá»¥ trÃªn thÃ¬ chÃºng ta pháº£i nhá» Ä‘áº¿n ngÆ°á»i anh em Array.from trÆ°á»›c sau Ä‘Ã³ má»›i sá»­ dá»¥ng forEach(). 
      Váº­y Arguments thá»±c sá»± lÃ  gÃ¬? Arguments cÃ³ thá»ƒ nÃ³i chÃ­nh lÃ  Array-like.
############################################
const
    The const declaration declares block-scoped local variables.
    The value of a constant can't be changed through reassignment using the assignment operator, but if a constant is an object,
    its properties can be added, updated, or removed.
    - const in objects and arrays
        - const also works on objects and arrays. Attempting to overwrite the object throws an error "Assignment to constant variable".
            - example: 
                - it is throw an error:
                    //object
                    const MY_OBJECT = { key: "value" };
                    MY_OBJECT = { OTHER_KEY: "value" };
                    //array
                    const MY_ARRAY = [];
                    MY_ARRAY = ["B"];
                - However, object keys are not protected, so the following statement is executed without problem.
                    MY_OBJECT.key = "otherValue";
                - Still, it's possible to push items into the array and thus mutate it.
                    MY_ARRAY.push("A"); // ["A"]
        - Declaration with destructuring
            - The left-hand side of each = can also be a binding pattern. This allows creating multiple variables at once.
                const result = /(a+)(b+)(c+)/.exec("aaabcc");
                const [, a, b, c] = result;
                console.log(a, b, c); // "aaa" "b" "cc"
            - But if we change the values of the variables above, it throw an error: Uncaught TypeError: Assignment to constant variable.
#############################################
Giáº£i thÃ­ch vá» Destructuring, Rest Parameters, vÃ  Spread Syntax trong javascript
    - Destructuring javascript lÃ  gÃ¬?
        - Destructuring lÃ  má»™t cÃº phÃ¡p cho phÃ©p báº¡n gÃ¡n cÃ¡c thuá»™c tÃ­nh cá»§a má»™t Object hoáº·c má»™t Array. 
          Äiá»u nÃ y cÃ³ thá»ƒ lÃ m giáº£m Ä‘Ã¡ng ká»ƒ cÃ¡c dÃ²ng mÃ£ cáº§n thiáº¿t Ä‘á»ƒ thao tÃ¡c dá»¯ liá»‡u trong cÃ¡c cáº¥u trÃºc nÃ y. 
          CÃ³ hai loáº¡i Destructuring: Destructuring Objects vÃ  Destructuring Arrays
            - Destructuring Objects:
                - Destructuring Objects cho phÃ©p báº¡n táº¡o ra má»™t hay nhiá»u  new variables  sá»­ dá»¥ng nhá»¯ng property cá»§a má»™t Objects. Xem vÃ­ dá»¥ dÆ°á»›i Ä‘Ã¢y:
                    - example: 
                        const note = {
                            id: 1,
                            website: 'anonystick.com',
                            date: '17/07/2014',
                        }
                    - Theo cÃ¡ch truyá»n thá»‘ng thÃ¬ chÃºng ta sáº½ láº¥y ra nhá»¯ng giÃ¡ trá»‹ nhÆ° cÃº phÃ¡p sau:
                        const id = note.id
                        const website = note.website
                        const date = note.date

                        console.log(id)
                        console.log(website)
                        console.log(date)
                    - NhÆ°ng vá»›i viá»‡c sá»­ dá»¥ng object destructuring chá»‰ vá»›i má»™t dÃ²ng code ( Thá»§ thuáº­t viáº¿t má»™t dÃ²ng code ),
                      chÃºng ta cÃ³ thá»ƒ get Ä‘Æ°á»£c nhá»¯ng giÃ¡ trá»‹ áº¥y miá»…n lÃ  trÃ¹ng tÃªn cá»§a thuá»™c tÃ­nh trong object lÃ  Ä‘Æ°á»£c:
                        // Destructure properties into variables
                        const { id, website, date } = note

                        console.log(id)
                        console.log(website)
                        console.log(date)
            - Destructuring Arrays:
                - Array destructuring cho phÃ©p báº¡n táº¡o ra má»™t new variables báº±ng cÃ¡ch sá»­ dá»¥ng giÃ¡ trá»‹ má»—i index cá»§a Array. 
                  Xem vÃ­ dá»¥ dÆ°á»›i Ä‘Ã¢y cho nÃ³ dá»… hiá»ƒu, chá»© nÃ³i váº­y cháº£ hiá»ƒu Ä‘Ã¢u. 
                  Ta cÃ³ má»™t Array lÃ  thÃ´ng tin vá» trang "blog javascript" Ä‘Æ°á»£c táº¡o ngÃ y
                    - example: 
                        const date = ['2014', '17', '07']
                    - NhÆ° á»Ÿ Object thÃ¬ ta láº§n lÆ°á»£t láº¥y giÃ¡ trá»‹ cá»§a má»—i item theo index
                        // Create variables from the Array items
                        const year = date[0]
                        const month = date[1]
                        const day = date[2]
                    - NhÆ°ng giá» Ä‘Ã¢y vá»›i viá»‡c sá»­ dá»¥ng Array Destructuring thÃ¬ cÃ´ng viá»‡c sáº½ trá»Ÿ nÃªn dáº¿ dÃ ng hÆ¡n nhiá»u
                        // Destructure Array values into variables
                        const [year, month, day] = date

                        console.log(year) // 2014
                        console.log(month) // 17
                        console.log(day) // 07
    - Spread operator lÃ  gÃ¬?
        - Spread operator lÃ  ba dáº¥u cháº¥m ( ...), cÃ³ thá»ƒ chuyá»ƒn Ä‘á»•i má»™t máº£ng thÃ nh má»™t chuá»—i cÃ¡c tham sá»‘ Ä‘Æ°á»£c phÃ¢n tÃ¡ch báº±ng dáº¥u pháº©y.
          NÃ³i cho dá»… hiá»ƒu, nÃ³ giá»‘ng nhÆ° má»™t cÃ¡i xÆ°Æ¡ng vÃ  má»™t cÃ¡i xÆ°Æ¡ng sÆ°á»n váº­y, chia nhá» má»™t pháº§n tá»­ lá»›n thÃ nh nhá»¯ng pháº§n tá»­ nhá» riÃªng láº».
        - NÃ³i vá» Spread tips javascript cÅ©ng Ä‘Ã£ cÃ³ ráº¥t nhiá»u bÃ i viáº¿t liÃªn quan Ä‘áº¿n tÃ­nh nÄƒng nÃ y. Spread syntax hay cÃ²n gá»i lÃ  three dot (...)
          lÃ  má»™t bá»• sung há»¯u Ã­ch khÃ¡c cho JavaScript Ä‘á»ƒ lÃ m viá»‡c vá»›i cÃ¡c Arrays, Objects vÃ  cÃ¡c function calls. 
        - HÆ¡n ná»¯a Spread cÃ³ thá»ƒ tao ra má»™t cáº¥u trÃºc dá»¯ liá»‡u shallow copy Ä‘á»ƒ tÄƒng tÃ­nh thao tÃ¡c dá»¯ liá»‡u. 
          CÅ©ng giá»‘ng nhÆ° destructuring thÃ¬ Spread cÅ©ng lÃ m viá»‡c nhiá»u vá»›i Arrays vÃ  Objects.
        - Spread with Arrays:
            - VÃ­ dá»¥ trÆ°á»ng há»£p thá»©c táº¿ thÃ¬ ta cÃ³ thá»ƒ merge array sá»­ dá»¥ng concat.
                // Create an Array
                const tools = ['hammer', 'screwdriver']
                const otherTools = ['wrench', 'saw']

                // Concatenate tools and otherTools together
                const allTools = tools.concat(otherTools)

                console.log(allTools);

                //(4) [
                "hammer",
                "screwdriver",
                "wrench",
                "saw"
                ]
            - NhÆ°ng giá» Ä‘Ã¢y Ä‘Ã£ khÃ¡c xÆ°a ráº¥t nhiá»u rá»“i, hÃ£y xem Ä‘Ã¢y khi sá»­ dá»¥ng Spread systax.
                // Unpack the tools Array into the allTools Array
                const allTools = [...tools, ...otherTools]
                console.log(allTools)
            - CÃ²n ráº¥t nhiá»u thá»© ráº¥t hay Ä‘ang chá» Ä‘Ã³n báº¡n, chÃºt ná»¯a sáº½ cung cáº¥p Ä‘anh cho nhá»¯ng ai Ä‘á»§ kiÃªn nháº«n Ä‘á»c háº¿t bÃ i viáº¿t nÃ y. 
                const ocean = ['ðŸ™', 'ðŸ¦€'];
                const aquarium = [...ocean, 'ðŸ¡']; // Add a single value
                const sushi = [...ocean, 'ðŸ¡', 'ðŸš']; // Add multiple values
                aquarium; // ['ðŸ™', 'ðŸ¦€', 'ðŸ¡']
                sushi; // ['ðŸ™', 'ðŸ¦€', 'ðŸ¡', 'ðŸš']
                // Original Array Not Affected
                ocean; // ['ðŸ™', 'ðŸ¦€']
        - Spread with Objects:
            - Khi sá»­ dá»¥ng Spread thÃ¬ chÃºng ta cÃ³ thá»ƒ copy vÃ  update má»™t object nhÆ° nhá»¯ng gÃ¬ mÃ  Object.assign() Ä‘Ã£ lÃ m
            - // Create an Object and a copied Object with Object.assign()
                const originalObject = { enabled: true, darkMode: false }
                const secondObject = Object.assign({}, originalObject)
                console.log(secondObject);//{enabled: true, darkMode: false}
            - Sá»­ dá»¥ng Spread syntax thÃ¬ sao? ez game.
                // Create an object and a copied object with spread
                const originalObject = { enabled: true, darkMode: false }
                const secondObject = { ...originalObject }
                console.log(secondObject);//{enabled: true, darkMode: false}
            - Spread with Function Calls
                - Giáº£ sá»­ chÃºng ta cÃ³ má»™t function nhÆ° tháº¿ nÃ y
                    // Create a function to multiply three items
                    function multiply(a, b, c) {
                        return a * b * c
                    }
                - Náº¿u bÃ¬nh thÆ°á»ng thÃ¬ sao, thÃ¬ add tá»«ng paramsx zÃ´ chá»© sao:
                    multiply(1, 2, 3) ;// 6
                - NhÆ°ng khi sá»­ dá»¥ng Spread trong function calls thÃ¬ ráº¥t Ä‘Æ¡n giáº£n
                    const numbers = [1, 2, 3]
                    multiply(...numbers);//6
    - Rest Parameters lÃ  gÃ¬?
        - TÃ­nh nÄƒng cuá»‘i cÃ¹ng báº¡n sáº½ tÃ¬m hiá»ƒu trong bÃ i viáº¿t nÃ y Ä‘Ã³ lÃ  Rest Parameters. CÃº phÃ¡p nÃ y giá»‘ng nhÆ° Spread Syntax (...) nhÆ°ng cÃ³ tÃ¡c dá»¥ng ngÆ°á»£c láº¡i.
          VÃ­ dá»¥ VÃ­ dá»¥, trong hÃ m restTest, náº¿u chÃºng ta muá»‘n args lÃ  má»™t máº£ng bao gá»“m má»™t sá»‘ lÆ°á»£ng Ä‘á»‘i sá»‘ khÃ´ng xÃ¡c Ä‘á»‹nh, chÃºng ta cÃ³ thá»ƒ cÃ³:
            function restTest(...args) {
                console.log(args)
            }
            restTest(1, 2, 3, 4, 5, 6);// [1, 2, 3, 4, 5, 6]
    - VÃ  Ä‘Ã¢y lÃ  má»™t bÃ i viáº¿t vá» Rest Parameters vÃ  Spread Syntax dÃ nh cho nhá»¯ng báº¡n kiÃªn nháº«n Ä‘á»c tá»›i Ä‘Ã¢y. 
      á»ž bÃ i viáº¿t nÃ y thÃ¬ má»i Ä‘iá»u sáº½ Ä‘Æ°á»£c sÃ¡ng tá», báº¡n sáº½ phÃ¢n biá»‡t Ä‘Æ°á»£c giá»¯a Rest Parameters vÃ  Spread Syntax. VÃ  khi nÃ o sá»­ dá»¥ng chÃºng.

#############################################
- The Nullish Coalescing Operator (??)
    - The ?? operator returns the first argument if it is not nullish (null or undefined). 
      Otherwise it returns the second argument.
        - Example:
            let name = null;
            let text = "missing";
            let result = name ?? text;
            -> result: missing
- The Optional Chaining Operator (?.):
    - The ?. operator returns undefined if an object is undefined or null (instead of throwing an error).
    - Example:
        // Create an object:
        const car = {type:"Fiat", model:"500", color:"white"};
        // Ask for car name:
        document.getElementById("demo").innerHTML = car?.name;
        -> result: undefined
#############################################
JavaScript Object Properties
    - Accessing JavaScript Properties:
        - The syntax for accessing the property of an object is:
            - objectName.property      // person.age
            or
            - objectName["property"]   // person["age"]
            or
            - objectName[expression]   // x = "age"; person[x]
        - The expression must evaluate to a property name.
##############################################
- JavaScript supports different kinds of loops:
    - for - loops through a block of code a number of times
    - for/in - loops through the properties of an object
    - for/of - loops through the values of an iterable object
    - while - loops through a block of code while a specified condition is true
    - do/while - also loops through a block of code while a specified condition is true
###################################################
- JavaScript Array Iteration
    - Array forEach()
        - The forEach() method calls a function for each element in an array.
        - The forEach() method is not executed for empty elements.
        - Syntax: array.forEach(function(currentValue, index, arr), thisValue)
        - Parameters:
            function(): Required. A function to run for each array element.
            currentValue: Required.The value of the current element.
            index: Optional.The index of the current element.
            arr: Optional. The array of the current element.
            thisValue: Optional. Default undefined. A value passed to the function as its this value.
        - Return Value: undefined
        - example 1:
            let sum = 0;
            const numbers = [65, 44, 12, 4];
            numbers.forEach(myFunction);

            function myFunction(item) {
                sum += item;
            }
        - example 2:
            const numbers = [65, 44, 12, 4];
            numbers.forEach(myFunction)

            function myFunction(item, index, arr) {
                arr[index] = item * 10;
            }
    - Array map():
        - The map() method creates a new array by performing a function on each array element.
        - The map() method does not execute the function for array elements without values.
        - The map() method does not change the original array.
        - Example:
            const numbers1 = [45, 4, 9, 16, 25];
            const numbers2 = numbers1.map(myFunction);

            function myFunction(value, index, array) {
                return value * 2;
            }
        - Note that the function takes 3 arguments:
            - The item value
            - The item index
            - The array itself
    - Array filter():
        - The filter() method creates a new array with array elements that pass a test.
        - This example creates a new array from elements with a value larger than 18:
        - Example:
            const numbers = [45, 4, 9, 16, 25];
            const over18 = numbers.filter(myFunction);

            function myFunction(value, index, array) {
                return value > 18;
            }
        - Note that the function takes 3 arguments:
            - The item value
            - The item index
            - The array itself
    - Array reduce():
        - The reduce() method runs a function on each array element to produce (reduce it to) a single value.
        - The reduce() method works from left-to-right in the array. See also reduceRight().
        - The reduce() method does not reduce the original array.
        - This example finds the sum of all numbers in an array:
        - Example
            const numbers = [45, 4, 9, 16, 25];
            let sum = numbers.reduce(myFunction);

            function myFunction(total, value, index, array) {
                return total + value;
            }
        - Note that the function takes 4 arguments:
            - The total (the initial value / previously returned value)
            - The item value
            - The item index
            - The array itself
    - Array every():
        - The every() method checks if all array values pass a test.
        - This example checks if all array values are larger than 18:
        - Example
            const numbers = [45, 4, 9, 16, 25];
            let allOver18 = numbers.every(myFunction);

            function myFunction(value, index, array) {
                return value > 18;
            }
            -> result: All over 18 is false
        - Note that the function takes 3 arguments:
            - The item value
            - The item index
            - The array itself
    - Array some():
        - The some() method checks if some array values pass a test.
        - This example checks if some array values are larger than 18:
        - Example
            const numbers = [45, 4, 9, 16, 25];
            let someOver18 = numbers.some(myFunction);

            function myFunction(value, index, array) {
                return value > 18;
            }
            -> result: Some over 18 is true
        - Note that the function takes 3 arguments:
            - The item value
            - The item index
            - The array itself
    - Array Spread (...):
        - The ... operator expands an iterable (like an array) into more elements:
        - Example:
            const q1 = ["Jan", "Feb", "Mar"];
            const q2 = ["Apr", "May", "Jun"];
            const q3 = ["Jul", "Aug", "Sep"];
            const q4 = ["Oct", "Nov", "May"];

            const year = [...q1, ...q2, ...q3, ...q4];
##############################################
- What is this?
        - In JavaScript, the this keyword refers to an object.
        - Which object depends on how this is being invoked (used or called).
        - The this keyword refers to different objects depending on how it is used:
            - In an object method, this refers to the object.
            - Alone, this refers to the global object.
            - In a function, this refers to the global object.
            - In a function, in strict mode, this is undefined.
            - In an event, this refers to the element that received the event.
            - Methods like call(), apply(), and bind() can refer this to any object.
            - this is not a variable. It is a keyword. You cannot change the value of this.
################################################
#####################################################
Object.defineProperties()
    - The Object.defineProperties() static method defines new or modifies existing properties directly on an object, returning the object.
        const object1 = {};
        Object.defineProperties(object1, {
        property1: {
            value: 42,
            writable: true,
        },
        property2: {},
        });
        console.log(object1.property1);
        // Expected output: 42
    - Syntax:
        Object.defineProperties(obj, props)
        - Parameters:
            - obj
                - The object on which to define or modify properties.
            - props:
                - An object whose keys represent the names of properties to be defined or
                  modified and whose values are objects describing those properties.
                  Each value in props must be either a data descriptor or an accessor descriptor;
                  it cannot be both (see Object.defineProperty() for more details).
                - Data descriptors and accessor descriptors may optionally contain the following keys:
                    - configurable: 
                        - true if and only if the type of this property descriptor may be changed
                          and if the property may be deleted from the corresponding object. Defaults to false.
                    - enumerable:
                        - true if and only if this property shows up during enumeration
                          of the properties on the corresponding object. Defaults to false.
                - A data descriptor also has the following optional keys:
                    - value
                        - The value associated with the property. 
                          Can be any valid JavaScript value (number, object, function, etc.). 
                          Defaults to undefined.
                    - writable
                        - true if and only if the value associated with the property may be changed
                          with an assignment operator. Defaults to false.
                - An accessor descriptor also has the following optional keys:
                    - get
                        - A function which serves as a getter for the property, or undefined if there is no getter.
                          The function's return value will be used as the value of the property. 
                          Defaults to undefined.

                    - set
                        - A function which serves as a setter for the property, or undefined if there is no setter.
                          The function will receive as its only argument the new value being assigned to the property. 
                          Defaults to undefined.
                - If a descriptor has neither of value, writable, get and set keys, it is treated as a data descriptor.
                  If a descriptor has both value or writable and get or set keys, an exception is thrown.
                - Return value:
                    - The object that was passed to the function.
                        const obj = {};
                        Object.defineProperties(obj, {
                            property1: {
                                value: true,
                                writable: true,
                            },
                            property2: {
                                value: "Hello",
                                writable: false,
                            },
                            // etc. etc.
                        });
#####################################################
Object.defineProperty()
    - The Object.defineProperty() static method defines a new property directly on an object, 
      or modifies an existing property on an object, and returns the object.
        const object1 = {};
        Object.defineProperty(object1, 'property1', {
            value: 42,
            writable: false,
        });
        object1.property1 = 77;
        // Throws an error in strict mode
        console.log(object1.property1);
        // Expected output: 42
    - Syntax:
        Object.defineProperty(obj, prop, descriptor)
        - Parameters:
            - obj
                The object on which to define the property.
            - prop
                A string or Symbol specifying the key of the property to be defined or modified.
            - descriptor
                The descriptor for the property being defined or modified.
    - Return value:
        - The object that was passed to the function, with the specified property added or modified.
    - Description:
        - Object.defineProperty() allows a precise addition to or modification of a property on an object.
          Normal property addition through assignment creates properties which show up during
          property enumeration (for...in, Object.keys(), etc.), whose values may be changed and which may be deleted.
          This method allows these extra details to be changed from their defaults. 
          By default, properties added using Object.defineProperty() are not writable, 
          not enumerable, and not configurable. In addition, Object.defineProperty() uses the [[DefineOwnProperty]] internal method,
          instead of [[Set]], so it does not invoke setters, even when the property is already present.
        - Property descriptors present in objects come in two main flavors: 
          data descriptors and accessor descriptors. A data descriptor is a property with a value that may or may not be writable.
          An accessor descriptor is a property described by a getter-setter pair of functions. 
          A descriptor must be one of these two flavors; it cannot be both.
        - Both data and accessor descriptors are objects. They share the following optional keys
          (please note: the defaults mentioned here are in the case of defining properties using Object.defineProperty()):
            - configurable:
                - the type of this property cannot be changed between data property and accessor property, and
                - the property may not be deleted, and
                - other attributes of its descriptor cannot be changed (however, if it's a data descriptor with writable: true,
                  the value can be changed, and writable can be changed to false).
                - Defaults to false.
            - enumerable:
                - true if and only if this property shows up during enumeration of the properties on the corresponding object. 
                - Defaults to false.
        - A data descriptor also has the following optional keys:
            - value
                - The value associated with the property. Can be any valid JavaScript value (number, object, function, etc.). 
                  Defaults to undefined.
            - writable
                - true if the value associated with the property may be changed with an assignment operator. 
                  Defaults to false.
        - An accessor descriptor also has the following optional keys:
            - get
                - A function which serves as a getter for the property, or undefined if there is no getter.
                  When the property is accessed, this function is called without arguments and with this set
                  to the object through which the property is accessed (this may not be the object on which the property is defined due to inheritance).
                  The return value will be used as the value of the property. 
                - Defaults to undefined.
            - set
                - A function which serves as a setter for the property, or undefined if there is no setter.
                  When the property is assigned, this function is called with one argument (the value being assigned to the property)
                  and with this set to the object through which the property is assigned. 
                - Defaults to undefined.
        - If a descriptor doesn't have any of the value, writable, get, and set keys, it is treated as a data descriptor. 
          If a descriptor has both [value or writable] and [get or set] keys, an exception is thrown.
        - These attributes are not necessarily the descriptor's own properties. 
          Inherited properties will be considered as well. In order to ensure these defaults are
          preserved, you might freeze existing objects in the descriptor object's prototype chain upfront,
          specify all options explicitly, or create a null-prototype object.
        - Creating a property
            - example:
                const o = {}; // Creates a new object

                // Example of an object property added
                // with defineProperty with a data property descriptor
                Object.defineProperty(o, "a", {
                    value: 37,
                    writable: true,
                    enumerable: true,
                    configurable: true,
                });
                // 'a' property exists in the o object and its value is 37
        - Modifying a property
            - Writable attribute:
                - When the writable property attribute is false, the property is said to be "non-writable". 
                  It cannot be reassigned. Trying to write to a non-writable property doesn't change it
                  and results in an error in strict mode.
                - example:
                    const o = {}; // Creates a new object
                    Object.defineProperty(o, "a", {
                        value: 37,
                        writable: false,
                    });
                    console.log(o.a); // 37
                    o.a = 25; // No error thrown
                    // (it would throw in strict mode,
                    // even if the value had been the same)
                    console.log(o.a); // 37; the assignment didn't work
                    // strict mode
                    (() => {
                        "use strict";
                        const o = {};
                        Object.defineProperty(o, "b", {
                            value: 2,
                            writable: false,
                        });
                        o.b = 3; // throws TypeError: "b" is read-only
                        return o.b; // returns 2 without the line above
                    })();
#################################################
JavaScript Object Prototypes
    - All JavaScript objects inherit properties and methods from a prototype.
    - Prototype Inheritance
        - All JavaScript objects inherit properties and methods from a prototype:
            - Date objects inherit from Date.prototype
            - Array objects inherit from Array.prototype
            - Person objects inherit from Person.prototype     
        - The Object.prototype is on the top of the prototype inheritance chain:
        - Date objects, Array objects, and Person objects inherit from Object.prototype.  
    - Adding Properties and Methods to Objects
        - Sometimes you want to add new properties (or methods) to all existing objects of a given type.
        - Sometimes you want to add new properties (or methods) to an object constructor. 
    - Using the prototype Property:
        - The JavaScript prototype property allows you to add new properties to object constructors:
            function Person(first, last, age, eyecolor) {
                this.firstName = first;
                this.lastName = last;
                this.age = age;
                this.eyeColor = eyecolor;
            }
            Person.prototype.nationality = "English";
        - The JavaScript prototype property also allows you to add new methods to objects constructors:
            function Person(first, last, age, eyecolor) {
                this.firstName = first;
                this.lastName = last;
                this.age = age;
                this.eyeColor = eyecolor;
            }
            Person.prototype.name = function() {
                return this.firstName + " " + this.lastName;
            };
    - Only modify your own prototypes. Never modify the prototypes of standard JavaScript objects.
####################################################
JavaScript Modules
    - JavaScript modules allow you to break up your code into separate files.
    - This makes it easier to maintain a code-base.
    - Modules are imported from external files with the import statement.
    - Modules also rely on type="module" in the <script> tag.
        <script type="module">
            import message from "./message.js";
        </script>
    - Export:
        - Modules with functions or variables can be stored in any external file.
        - There are two types of exports: Named Exports and Default Exports.

        - Named Exports:
            - Let us create a file named person.js, and fill it with the things we want to export.
            - You can create named exports two ways. In-line individually, or all at once at the bottom.
            - In-line individually:
                - person.js:
                    export const name = "Jesse";
                    export const age = 40;
            - All at once at the bottom:
                - person.js:
                    const name = "Jesse";
                    const age = 40;
                    export {name, age};
        - Default Exports:
            - Let us create another file, named message.js, and use it for demonstrating default export.
            - You can only have one default export in a file.
                - message.js
                    const message = () => {
                        const name = "Jesse";
                        const age = 40;
                        return name + ' is ' + age + 'years old.';
                    };
                    export default message;
    - Import:
        - You can import modules into a file in two ways, based on if they are named exports or default exports.
        - Named exports are constructed using curly braces. Default exports are not.
        - Import from named exports:
            - Import named exports from the file person.js:
                import { name, age } from "./person.js";
        - Import from default exports:
            - Import a default export from the file message.js:
                import message from "./message.js";
    - Modules only work with the HTTP(s) protocol.
    - A web-page opened via the file:// protocol cannot use import / export.
#######################################
JavaScript Function call()
    - Method Reuse:
        - With the call() method, you can write a method that can be used on different objects.
    - All Functions are Methods:
        - In JavaScript all functions are object methods.
        - If a function is not a method of a JavaScript object, it is a function of the global object (see previous chapter).
        - The example below creates an object with 3 properties, firstName, lastName, fullName.
        - Example
            const person = {
                firstName:"John",
                lastName: "Doe",
                fullName: function () {
                    return this.firstName + " " + this.lastName;
                }
            }
            // This will return "John Doe":
            person.fullName();
        - In the example above, this refers to the person object.
        - this.firstName means the firstName property of this.
        - Same as: this.firstName means the firstName property of person.
    - The JavaScript call() Method:
        - The call() method is a predefined JavaScript method.
        - It can be used to invoke (call) a method with an owner object as an argument (parameter).
        - With call(), an object can use a method belonging to another object.
        - This example calls the fullName method of person, using it on person1:
            const person = {
                fullName: function() {
                    return this.firstName + " " + this.lastName;
                }
            }
            const person1 = {
                firstName:"John",
                lastName: "Doe"
            }
            const person2 = {
                firstName:"Mary",
                lastName: "Doe"
            }
            // This will return "John Doe":
            person.fullName.call(person1);
        - This example calls the fullName method of person, using it on person2:
            const person = {
                fullName: function() {
                    return this.firstName + " " + this.lastName;
                }
            }
            const person1 = {
                firstName:"John",
                lastName: "Doe"
            }
            const person2 = {
                firstName:"Mary",
                lastName: "Doe"
            }
            // This will return "Mary Doe"
            person.fullName.call(person2);
        - The call() Method with Arguments:
            - The call() method can accept arguments:
                const person = {
                    fullName: function(city, country) {
                        return this.firstName + " " + this.lastName + "," + city + "," + country;
                    }
                }
                const person1 = {
                    firstName:"John",
                    lastName: "Doe"
                }
                person.fullName.call(person1, "Oslo", "Norway");
#############################################
JavaScript Function apply()
    - Method Reuse
        - With the apply() method, you can write a method that can be used on different objects.
    - The JavaScript apply() Method
        - The apply() method is similar to the call() method (previous chapter).
        - In this example the fullName method of person is applied on person1:
            const person = {
                fullName: function() {
                    return this.firstName + " " + this.lastName;
                }
            }
            const person1 = {
                firstName: "Mary",
                lastName: "Doe"
            }
            // This will return "Mary Doe":
            person.fullName.apply(person1);
    - The Difference Between call() and apply()
        - The call() method takes arguments separately.
        - The apply() method takes arguments as an array.
        - The apply() method is very handy if you want to use an array instead of an argument list.
    - The apply() Method with Arguments:
        - The apply() method accepts arguments in an array:
            const person = {
                fullName: function(city, country) {
                    return this.firstName + " " + this.lastName + "," + city + "," + country;
                }
            }
            const person1 = {
                firstName:"John",
                lastName: "Doe"
            }
            person.fullName.apply(person1, ["Oslo", "Norway"]);
        - Compared with the call() method:
            const person = {
                fullName: function(city, country) {
                    return this.firstName + " " + this.lastName + "," + city + "," + country;
                }
            }
            const person1 = {
                firstName:"John",
                lastName: "Doe"
            }
            person.fullName.call(person1, "Oslo", "Norway");
######################################
JavaScript Function bind()
    - Function Borrowing
        - With the bind() method, an object can borrow a method from another object.
        - The example below creates 2 objects (person and member).
        - The member object borrows the fullname method from the person object:
            const person = {
                firstName:"John",
                lastName: "Doe",
                fullName: function () {
                    return this.firstName + " " + this.lastName;
                }
            }
            const member = {
                firstName:"Hege",
                lastName: "Nilsen",
            }
            let fullName = person.fullName.bind(member);
    - Preserving this:
        - Sometimes the bind() method has to be used to prevent losing this.
        - In the following example, the person object has a display method. In the display method, this refers to the person object:
            const person = {
                firstName:"John",
                lastName: "Doe",
                display: function () {
                    let x = document.getElementById("demo");
                    x.innerHTML = this.firstName + " " + this.lastName;
                }
            }
            person.display();
        - When a function is used as a callback, this is lost.
        - This example will try to display the person name after 3 seconds, but it will display undefined instead:
            const person = {
                firstName:"John",
                lastName: "Doe",
                display: function () {
                    let x = document.getElementById("demo");
                    x.innerHTML = this.firstName + " " + this.lastName;
                }
            }
            setTimeout(person.display, 3000);
            -> result: undefined undefined
        - The bind() method solves this problem.
        - In the following example, the bind() method is used to bind person.display to person.
        - This example will display the person name after 3 seconds:
            const person = {
                firstName:"John",
                lastName: "Doe",
                display: function () {
                    let x = document.getElementById("demo");
                    x.innerHTML = this.firstName + " " + this.lastName;
                }
            }

            let display = person.display.bind(person);
            setTimeout(display, 3000);
######################################
The JavaScript this Keyword:
    -Example
        const person = {
            firstName: "John",
            lastName : "Doe",
            id       : 5566,
            fullName : function() {
                return this.firstName + " " + this.lastName;
            }
        };
    - What is this?
        - In JavaScript, the this keyword refers to an object.
        - Which object depends on how this is being invoked (used or called).
        - The this keyword refers to different objects depending on how it is used:
            - In an object method, this refers to the object.
            - Alone, this refers to the global object.
            - In a function, this refers to the global object.
            - In a function, in strict mode, this is undefined.
            - In an event, this refers to the element that received the event.
            - Methods like call(), apply(), and bind() can refer this to any object.
            - this is not a variable. It is a keyword. You cannot change the value of this.
    - this in a Method:
        - When used in an object method, this refers to the object.
        - In the example on top of this page, this refers to the person object.
        - Because the fullName method is a method of the person object.
    - this Alone:
        - When used alone, this refers to the global object.
        - Because this is running in the global scope.
        - In a browser window the global object is [object Window]:
            let x = this;
        - In strict mode, when used alone, this also refers to the global object:
            "use strict";
            let x = this;
    - this in a Function (Default):
        - In a function, the global object is the default binding for this.
        - In a browser window the global object is [object Window]:
            function myFunction() {
                return this;
            }
    - this in a Function (Strict):
        - JavaScript strict mode does not allow default binding.
        - So, when used in a function, in strict mode, this is undefined.
    - this in Event Handlers:
        - In HTML event handlers, this refers to the HTML element that received the event:
            ex: <button onclick="this.style.display='none'">Click to Remove Me!</button>
    - Object Method Binding:
        - In these examples, this is the person object:
            const person = {
                firstName  : "John",
                lastName   : "Doe",
                id         : 5566,
                myFunction : function() {
                    return this;
                }
            };

            const person = {
                firstName: "John",
                lastName : "Doe",
                id       : 5566,
                fullName : function() {
                    return this.firstName + " " + this.lastName;
                }
            };
            i.e. this.firstName is the firstName property of this (the person object).
    - Explicit Function Binding:
        - The call() and apply() methods are predefined JavaScript methods.
        - They can both be used to call an object method with another object as argument.
        - The example below calls person1.fullName with person2 as an argument,
          this refers to person2, even if fullName is a method of person1:
            const person1 = {
                fullName: function() {
                    return this.firstName + " " + this.lastName;
                }
            }
            const person2 = {
                firstName:"John",
                lastName: "Doe",
            }
            // Return "John Doe"; object person2 call method fullName
            person1.fullName.call(person2);
    - Function Borrowing:
        - With the bind() method, an object can borrow a method from another object.
        - This example creates 2 objects (person and member).
        - The member object borrows the fullname method from the person object:
            const person = {
                firstName:"John",
                lastName: "Doe",
                fullName: function () {
                    return this.firstName + " " + this.lastName;
                }
            }
            const member = {
                firstName:"Hege",
                lastName: "Nilsen",
            }
            let fullName = person.fullName.bind(member);
####################################
ES6 Arrow Functions:
    - Block body thÃ¬ => return keyword cáº§n cÃ³
    - Concise(dáº¡ng ngáº¯n gá»n) body thÃ¬ => return keyword lÃ  implied vÃ  khÃ´ng cáº§n thiáº¿t
        Example A: Normal Function
        const sayHi = function(name) {
            return name
        }

        Example B: Arrow Function with Explicit Return
        // Multi-line
        const sayHi = (name) => {
            return name
        }

        // Single-line
        const sayHi = (name) => { return name }

        Example C: Arrow Function with Implicit Return
        // Single-line
        const sayHi = (name) => name

        // Multi-line
        const sayHi = (name) => (
            name
        )
    - Returning Objects:
        - const me = () => { name: "samantha" };
            me(); // undefined ðŸ˜±
        - const me = () => ({ name: "samantha" });
            me(); // { name: "samantha" }
##################################
ExpressJS

    - vÃ­ dá»¥:
        import express from "express";
        import mongoose from "mongoose";
        import dotenv from "dotenv";
        import userRoute from "./routes/user.route.js";
        import gigRoute from "./routes/gig.route.js";
        import orderRoute from "./routes/order.route.js";
        import conversationRoute from "./routes/conversation.route.js";
        import messageRoute from "./routes/message.route.js";
        import reviewRoute from "./routes/review.route.js";
        import authRoute from "./routes/auth.route.js";
        import uploadRoute from "./routes/upload.route.js";
        import cookieParser from "cookie-parser";
        import cors from "cors";

        const app = express();
        mongoose.set("strictQuery", true);
        dotenv.config();
        app.use(express.urlencoded({
            extended: true
        }))

        const connect = async () => {
            try {
                await mongoose.connect(process.env.MONGO);
                console.log("Connected to mongoDB!");
            } catch (error) {
                console.log(error.message);
            }
        };

        // cáº§n sá»­ dá»¥ng thÆ° viá»‡n nÃ y vÃ¬ náº¿u ta gá»i tá»« á»©ng bÃªn client cháº¡y react Ä‘áº¿n api, sáº½ gáº·p lá»—i 
        // cors policy vÃ¬ chÃºng ta Ä‘ang cá»‘ truy cáº­p Ä‘áº¿n api tá»« má»™t nÆ¡i khÃ¡c. thÆ° viá»‡n nÃ y cho phÃ©p ta
        // nÃ³i vá»›i á»©ng dá»¥ng lÃ  cho phÃ©p domain nÃ y truy cáº­p vÃ o api cá»§a chÃºng ta
        app.use(cors({ origin: "http://localhost:5173", credentials: true }));

        app.use(express.json());
        app.use(cookieParser());

        app.use("/api/auth", authRoute);
        app.use("/api/users", userRoute);
        app.use("/api/gigs", gigRoute);
        app.use("/api/orders", orderRoute);
        app.use("/api/conversations", conversationRoute);
        app.use("/api/messages", messageRoute);
        app.use("/api/reviews", reviewRoute);
        app.use("/api/upload", uploadRoute);

        app.use((err, req, res, next) => {
            const errorStatus = err.status || 500;
            const errorMessage = err.message || "Something went wrong";
            return res.status(errorStatus).send(errorMessage);
        });
        app.listen(8000, () => {
            connect();
            console.log("Backend server is running");
        });
- CÃ´ng dá»¥ng cá»§a hÃ m app.use:
    - ÄÄƒng kÃ½ middleware: HÃ m app.use Ä‘Æ°á»£c sá»­ dá»¥ng Ä‘á»ƒ Ä‘Äƒng kÃ½ middleware vá»›i á»©ng dá»¥ng Express. 
      Middleware lÃ  cÃ¡c hÃ m Ä‘Æ°á»£c sá»­ dá»¥ng Ä‘á»ƒ xá»­ lÃ½ cÃ¡c yÃªu cáº§u HTTP trÆ°á»›c khi chÃºng Ä‘Æ°á»£c chuyá»ƒn Ä‘áº¿n cÃ¡c tuyáº¿n Ä‘Æ°á»ng.
    - Xá»­ lÃ½ cÃ¡c yÃªu cáº§u: Middleware cÃ³ thá»ƒ Ä‘Æ°á»£c sá»­ dá»¥ng Ä‘á»ƒ thá»±c hiá»‡n cÃ¡c tÃ¡c vá»¥ nhÆ°:
        - XÃ¡c thá»±c vÃ  á»§y quyá»n
        - PhÃ¢n tÃ­ch dá»¯ liá»‡u yÃªu cáº§u
        - Ghi nháº­t kÃ½
        - Xá»­ lÃ½ lá»—i
    - Cáº¥u hÃ¬nh linh hoáº¡t: HÃ m app.use cho phÃ©p báº¡n cáº¥u hÃ¬nh á»©ng dá»¥ng Express theo cÃ¡ch linh hoáº¡t. 
      Báº¡n cÃ³ thá»ƒ Ä‘Äƒng kÃ½ middleware cho cÃ¡c tuyáº¿n Ä‘Æ°á»ng cá»¥ thá»ƒ hoáº·c cho toÃ n bá»™ á»©ng dá»¥ng.

- Thá»© tá»± thá»±c hiá»‡n middleware vÃ  sá»‘ lÆ°á»£ng Ä‘á»‘i sá»‘ trong hÃ m callback
    - Thá»© tá»± thá»±c hiá»‡n middleware:
        - Middleware Ä‘Æ°á»£c thá»±c thi theo thá»© tá»± Ä‘Æ°á»£c khai bÃ¡o trong mÃ£.
        - Middleware Ä‘Æ°á»£c Ä‘áº·t trÆ°á»›c sáº½ Ä‘Æ°á»£c thá»±c thi trÆ°á»›c, sau Ä‘Ã³ Ä‘áº¿n cÃ¡c middleware Ä‘Æ°á»£c Ä‘áº·t sau.
- Sá»‘ lÆ°á»£ng Ä‘á»‘i sá»‘ trong hÃ m callback:
    - Sá»‘ lÆ°á»£ng Ä‘á»‘i sá»‘ trong hÃ m callback cá»§a middleware khÃ´ng áº£nh hÆ°á»Ÿng Ä‘áº¿n thá»© tá»± thá»±c hiá»‡n.
    - NÃ³ chá»‰ áº£nh hÆ°á»Ÿng Ä‘áº¿n chá»©c nÄƒng cá»§a middleware.
- VÃ­ dá»¥:
    app.use((req, res, next) => {
    console.log('Middleware 1');
    next();
    });

    app.use((req, res, next) => {
    console.log('Middleware 2');
    next();
    });

    app.get('/', (req, res) => {
    res.send('Hello World!');
    });

    app.listen(3000);
- Trong vÃ­ dá»¥ nÃ y, cáº£ hai middleware Ä‘á»u cÃ³ 3 Ä‘á»‘i sá»‘: req, res vÃ  next.
- Tuy nhiÃªn, middleware 1 sáº½ Ä‘Æ°á»£c thá»±c thi trÆ°á»›c middleware 2 vÃ¬ nÃ³ Ä‘Æ°á»£c khai bÃ¡o trÆ°á»›c.

- Báº£ng sau Ä‘Ã¢y tÃ³m táº¯t sá»‘ lÆ°á»£ng Ä‘á»‘i sá»‘ phá»• biáº¿n trong hÃ m callback cá»§a middleware vÃ  chá»©c nÄƒng cá»§a chÃºng:

    Sá»‘ lÆ°á»£ng Ä‘á»‘i    sá»‘	Chá»©c nÄƒng
    4	            Middleware xá»­ lÃ½ lá»—i
    3	            Middleware thÃ´ng thÆ°á»ng
    2	            Middleware chá»‰ xá»­ lÃ½ request vÃ  response

- LÆ°u Ã½:
    - Báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng báº¥t ká»³ sá»‘ lÆ°á»£ng Ä‘á»‘i sá»‘ nÃ o trong hÃ m callback cá»§a middleware.
    - Tuy nhiÃªn, 3 Ä‘á»‘i sá»‘ lÃ  phá»• biáº¿n nháº¥t.
    - Middleware xá»­ lÃ½ lá»—i pháº£i cÃ³ 4 Ä‘á»‘i sá»‘.

Káº¿t luáº­n:

    - Thá»© tá»± thá»±c hiá»‡n middleware Ä‘Æ°á»£c xÃ¡c Ä‘á»‹nh bá»Ÿi thá»© tá»± khai bÃ¡o trong mÃ£, khÃ´ng pháº£i bá»Ÿi sá»‘ lÆ°á»£ng Ä‘á»‘i sá»‘ trong hÃ m callback.
      Sá»‘ lÆ°á»£ng Ä‘á»‘i sá»‘ chá»‰ áº£nh hÆ°á»Ÿng Ä‘áº¿n chá»©c nÄƒng cá»§a middleware.

- HÃ m app.listen(3000); Ä‘Æ°á»£c Ä‘áº·t á»Ÿ cuá»‘i cÃ¹ng Ä‘á»ƒ Ä‘áº£m báº£o ráº±ng táº¥t cáº£ cÃ¡c middleware vÃ  tuyáº¿n Ä‘Æ°á»ng Ä‘Ã£ Ä‘Æ°á»£c Ä‘á»‹nh nghÄ©a trÆ°á»›c
  khi mÃ¡y chá»§ Express báº¯t Ä‘áº§u láº¯ng nghe cÃ¡c yÃªu cáº§u.
#################################
- HÃ m next
    HÃ m next Ä‘Æ°á»£c sá»­ dá»¥ng trong middleware Ä‘á»ƒ chuyá»ƒn tiáº¿p yÃªu cáº§u Ä‘áº¿n middleware tiáº¿p theo trong chuá»—i.
    NÃ³ hoáº¡t Ä‘á»™ng nhÆ° má»™t cá» hiá»‡u Ä‘á»ƒ cho biáº¿t middleware hiá»‡n táº¡i Ä‘Ã£ hoÃ n táº¥t viá»‡c xá»­ lÃ½ yÃªu cáº§u vÃ  middleware tiáº¿p theo cÃ³ thá»ƒ báº¯t Ä‘áº§u.

- CÃ¡ch thá»©c hoáº¡t Ä‘á»™ng:
    - Khi má»™t middleware Ä‘Æ°á»£c gá»i, nÃ³ cÃ³ thá»ƒ thá»±c hiá»‡n má»™t sá»‘ thao tÃ¡c vá»›i yÃªu cáº§u vÃ  pháº£n há»“i.
    - Náº¿u middleware muá»‘n chuyá»ƒn tiáº¿p yÃªu cáº§u Ä‘áº¿n middleware tiáº¿p theo, nÃ³ cáº§n gá»i hÃ m next.
    - Náº¿u middleware khÃ´ng gá»i next, yÃªu cáº§u sáº½ khÃ´ng Ä‘Æ°á»£c chuyá»ƒn tiáº¿p vÃ  sáº½ dá»«ng láº¡i táº¡i middleware hiá»‡n táº¡i.
- VÃ­ dá»¥:
    app.use((req, res, next) => {
    console.log('Middleware 1');
    next();
    });

    app.use((req, res, next) => {
    console.log('Middleware 2');
    next();
    });

    app.get('/', (req, res) => {
    res.send('Hello World!');
    });

    app.listen(3000);

    - Trong vÃ­ dá»¥ nÃ y, khi má»™t yÃªu cáº§u Ä‘Æ°á»£c gá»­i Ä‘áº¿n /, nÃ³ sáº½ Ä‘Æ°á»£c xá»­ lÃ½ bá»Ÿi hai middleware trÆ°á»›c khi Ä‘áº¿n Ä‘Æ°á»£c tuyáº¿n Ä‘Æ°á»ng. 
    - Má»—i middleware sáº½ ghi nháº­t kÃ½ má»™t thÃ´ng bÃ¡o vÃ o báº£ng Ä‘iá»u khiá»ƒn vÃ  sau Ä‘Ã³ gá»i next Ä‘á»ƒ chuyá»ƒn tiáº¿p yÃªu cáº§u Ä‘áº¿n middleware tiáº¿p theo.

- LÆ°u Ã½:
    - HÃ m next khÃ´ng báº¯t buá»™c pháº£i Ä‘Æ°á»£c gá»i trong middleware.
    - Náº¿u báº¡n khÃ´ng gá»i next, yÃªu cáº§u sáº½ dá»«ng láº¡i táº¡i middleware hiá»‡n táº¡i.
    - Báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng next Ä‘á»ƒ chuyá»ƒn tiáº¿p yÃªu cáº§u Ä‘áº¿n má»™t middleware cá»¥ thá»ƒ.

- CÃ´ng dá»¥ng khÃ¡c cá»§a next:
    - Bá» qua cÃ¡c middleware: Báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng next('route') Ä‘á»ƒ bá» qua cÃ¡c middleware cÃ²n láº¡i vÃ  chuyá»ƒn tiáº¿p yÃªu cáº§u Ä‘áº¿n má»™t tuyáº¿n Ä‘Æ°á»ng cá»¥ thá»ƒ.
    - Gá»­i lá»—i: Báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng next(new Error('Error message')) Ä‘á»ƒ gá»­i má»™t lá»—i Ä‘áº¿n middleware xá»­ lÃ½ lá»—i.
- Káº¿t luáº­n:
    - HÃ m next lÃ  má»™t pháº§n quan trá»ng trong viá»‡c xá»­ lÃ½ cÃ¡c yÃªu cáº§u trong á»©ng dá»¥ng Express. 
    - NÃ³ cho phÃ©p báº¡n kiá»ƒm soÃ¡t luá»“ng yÃªu cáº§u vÃ  chuyá»ƒn tiáº¿p yÃªu cáº§u Ä‘áº¿n cÃ¡c middleware khÃ¡c nhau.
################################################
- MÃ¬nh cÃ³ má»™t website, mÃ¬nh muá»‘n website Ä‘Ã³ Ä‘Æ°á»£c hiá»ƒn thá»‹ lÃªn tÃ¬m kiáº¿m cá»§a google thÃ¬ mÃ¬nh cáº§n thiáº¿t láº­p nhá»¯ng gÃ¬?
    Äá»ƒ website cá»§a báº¡n Ä‘Æ°á»£c hiá»ƒn thá»‹ lÃªn káº¿t quáº£ tÃ¬m kiáº¿m cá»§a Google, báº¡n cáº§n chÃº Ã½ Ä‘áº¿n nhá»¯ng yáº¿u tá»‘ sau:
    1. Search Engine Optimization (SEO): Tá»‘i Æ°u hÃ³a website cho cÃ´ng cá»¥ tÃ¬m kiáº¿m lÃ  bÆ°á»›c khÃ´ng thá»ƒ bá» qua, gá»“m cÃ³:
        - Tá»‘i Æ°u hÃ³a ná»™i dung: Sá»­ dá»¥ng cÃ¡c tá»« khÃ³a liÃªn quan Ä‘áº¿n ngÃ nh nghá» hoáº·c chá»§ Ä‘á» mÃ  trang web cá»§a báº¡n táº­p trung vÃ o.
        - Meta tags: Cung cáº¥p meta descriptions vÃ  meta titles cÃ³ chá»©a tá»« khÃ³a.
        - Tá»‘i Æ°u hÃ³a hÃ¬nh áº£nh: Sá»­ dá»¥ng alt tags cho hÃ¬nh áº£nh vÃ  tá»‘i Æ°u hÃ³a kÃ­ch thÆ°á»›c cá»§a áº£nh Ä‘á»ƒ táº£i trang nhanh hÆ¡n.
        - Ná»™i dung cháº¥t lÆ°á»£ng: Äáº£m báº£o báº¡n cung cáº¥p thÃ´ng tin cÃ³ giÃ¡ trá»‹, Ä‘á»™c Ä‘Ã¡o vÃ  thÆ°á»ng xuyÃªn cáº­p nháº­t.
    2. Mobile-friendly: Äáº£m báº£o ráº±ng website cá»§a báº¡n tÆ°Æ¡ng thÃ­ch vá»›i thiáº¿t bá»‹ di Ä‘á»™ng, vÃ¬ Google chuá»™ng cÃ¡c trang web thÃ¢n thiá»‡n vá»›i mobile.
    3. Page Speed: TÄƒng tá»‘c Ä‘á»™ táº£i trang cá»§a báº¡n vÃ¬ tá»‘c Ä‘á»™ táº£i trang lÃ  má»™t yáº¿u tá»‘ xáº¿p háº¡ng quan trá»ng cá»§a Google.
    4. Backlinks: XÃ¢y dá»±ng backlinks cháº¥t lÆ°á»£ng tá»« cÃ¡c trang web uy tÃ­n, Ä‘iá»u nÃ y cÃ ng chá»©ng minh cho Google ráº±ng trang web cá»§a báº¡n cÃ³ giÃ¡ trá»‹.
    5. Google Search Console: ÄÄƒng kÃ½ sá»­ dá»¥ng Google Search Console Ä‘á»ƒ theo dÃµi cÃ¡ch Google xem vÃ  xáº¿p háº¡ng trang web cá»§a báº¡n.
    6. Sitemaps vÃ  robots.txt: Táº¡o vÃ  gá»­i sitemap cho Google Ä‘á»ƒ giÃºp Google tÃ¬m vÃ  láº­p chá»‰ má»¥c cÃ¡c trang cá»§a báº¡n nhanh chÃ³ng hÆ¡n, vÃ  sá»­ dá»¥ng file robots.txt
       Ä‘á»ƒ hÆ°á»›ng dáº«n bots cá»§a cÃ´ng cá»¥ tÃ¬m kiáº¿m cÃ¡ch tiáº¿p cáº­n trang web cá»§a báº¡n.
    7. Social Media vÃ  Marketing Content: Sá»­ dá»¥ng máº¡ng xÃ£ há»™i vÃ  content marketing Ä‘á»ƒ táº¡o traffic tá»± nhiÃªn vá» trang web cá»§a báº¡n.
    8. Local SEO: Náº¿u báº¡n cÃ³ doanh nghiá»‡p Ä‘á»‹a phÆ°Æ¡ng, hÃ£y Ä‘áº£m báº£o ráº±ng báº¡n cÃ³ danh sÃ¡ch trÃªn Google My Business.
    9. Rich Snippets: Sá»­ dá»¥ng Schema markup Ä‘á»ƒ giÃºp Google hiá»ƒu ná»™i dung cá»§a trang báº¡n tá»‘t hÆ¡n vÃ  cÃ³ thá»ƒ hiá»ƒn thá»‹ ná»™i dung ná»•i báº­t
       cá»§a báº¡n thÃ nh cÃ¡c rich snippets trÃªn trang káº¿t quáº£ tÃ¬m kiáº¿m.
    10. Security: Sá»­ dá»¥ng HTTPS Ä‘á»ƒ báº£o máº­t thÃ´ng tin cá»§a ngÆ°á»i dÃ¹ng vÃ  tÄƒng cÆ¡ há»™i Ä‘Æ°á»£c xáº¿p háº¡ng cao hÆ¡n trong káº¿t quáº£ tÃ¬m kiáº¿m cá»§a Google.
    Hiá»ƒu biáº¿t sÃ¢u sáº¯c vÃ  Ã¡p dá»¥ng Ä‘Ãºng cÃ¡ch nhá»¯ng yáº¿u tá»‘ trÃªn sáº½ giÃºp website cá»§a báº¡n tá»‘i Æ°u hÃ³a Ä‘Æ°á»£c hiá»‡u suáº¥t trÃªn cÃ´ng cá»¥ tÃ¬m kiáº¿m vÃ  gia tÄƒng kháº£ nÄƒng hiá»ƒn thá»‹.

- Báº¡n cÃ³ thá»ƒ hÆ°á»›ng dáº«n mÃ¬nh vá» bÆ°á»›c 5 vÃ  6 khÃ´ng

    ### BÆ°á»›c 5: Sá»­ dá»¥ng Google Search Console

        Google Search Console (GSC) lÃ  má»™t dá»‹ch vá»¥ miá»…n phÃ­ cá»§a Google giÃºp báº¡n theo dÃµi vÃ  duy trÃ¬ sá»± hiá»‡n diá»‡n cá»§a website trong káº¿t quáº£ tÃ¬m kiáº¿m Google. ÄÃ¢y lÃ  cÃ¡ch báº¡n sá»­ dá»¥ng GSC:

        1. ÄÄƒng kÃ½: Truy cáº­p Google Search Console vÃ  sá»­ dá»¥ng tÃ i khoáº£n Google Ä‘á»ƒ Ä‘Äƒng kÃ½.
        2. XÃ¡c minh website: Báº¡n cáº§n xÃ¡c minh sá»Ÿ há»¯u trang web cá»§a mÃ¬nh. CÃ³ nhiá»u cÃ¡ch Ä‘á»ƒ lÃ m Ä‘iá»u nÃ y, vÃ­ dá»¥ nhÆ° táº£i lÃªn má»™t file HTML vÃ o root directory cá»§a website, hoáº·c thÃªm má»™t tháº» meta vÃ o homepage.
        3. Gá»­i Sitemap: Sitemap lÃ  má»™t file XML chá»©a danh sÃ¡ch cÃ¡c URLs trong site cá»§a báº¡n vÃ  cÃ³ thá»ƒ giÃºp Google dá»… dÃ ng tÃ¬m vÃ  láº­p chá»‰ má»¥c trang web. Táº¡o sitemap vÃ  gá»­i nÃ³ thÃ´ng qua GSC.
        4. GiÃ¡m sÃ¡t: Theo dÃµi cÃ¡c chá»‰ sá»‘ hiá»‡u suáº¥t, nhÆ° sá»‘ láº§n click, sá»‘ láº§n hiá»ƒn thá»‹, vá»‹ trÃ­ trung bÃ¬nh cá»§a cÃ¡c tá»« khÃ³a vÃ  nhiá»u thá»© khÃ¡c.
        5. Kiá»ƒm tra lá»—i: Sá»­ dá»¥ng GSC Ä‘á»ƒ kiá»ƒm tra xem cÃ³ lá»—i láº­p chá»‰ má»¥c hay lá»—i mobile usability nÃ o khÃ´ng vÃ  sá»­a chÃºng.
        6. Tá»‘i Æ°u hÃ³a: Sá»­ dá»¥ng thÃ´ng tin tá»« GSC Ä‘á»ƒ tá»‘i Æ°u hÃ³a tá»« khÃ³a vÃ  cáº£i thiá»‡n chiáº¿n lÆ°á»£c ná»™i dung cá»§a báº¡n.

    ### BÆ°á»›c 6: Táº¡o vÃ  sá»­ dá»¥ng Sitemaps vÃ  robots.txt

        1. Sitemaps:
            - Táº¡o sitemap dáº¡ng XML cho website cá»§a báº¡n, cÃ´ng cá»¥ táº¡o sitemap miá»…n phÃ­ trá»±c tuyáº¿n cÃ³ thá»ƒ giÃºp báº¡n náº¿u website chÆ°a cÃ³ sitemap.
            - Má»™t sitemap thÃ´ng thÆ°á»ng nÃªn cáº­p nháº­t Ä‘á»‹nh ká»³ vÃ  gá»“m cÃ³ cÃ¡c trang quan trá»ng cá»§a báº¡n.
            - Gá»­i sitemap Ä‘áº¿n Google thÃ´ng qua Google Search Console Ä‘á»ƒ giÃºp Google láº­p chá»‰ má»¥c trang web cá»§a báº¡n nhanh chÃ³ng vÃ  dá»… dÃ ng hÆ¡n.

        2. robots.txt:
            - File robots.txt lÃ  má»™t file vÄƒn báº£n Ä‘Æ°á»£c Ä‘áº·t á»Ÿ root cá»§a domain Ä‘á»ƒ hÆ°á»›ng dáº«n cÃ¡c web crawler xem nÃªn vÃ  khÃ´ng nÃªn láº­p chá»‰ má»¥c pháº§n nÃ o cá»§a website.
            - Báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng file nÃ y Ä‘á»ƒ loáº¡i trá»« cÃ¡c trang khÃ´ng muá»‘n cÃ´ng cá»¥ tÃ¬m kiáº¿m láº­p chá»‰ má»¥c, nhÆ°ng hÃ£y cáº©n tháº­n vÃ¬ sai sÃ³t cÃ³ thá»ƒ ngÄƒn cáº£n Google láº­p chá»‰ má»¥c cÃ¡c trang quan trá»ng.
            - CÃº phÃ¡p cá»§a robots.txt lÃ  khÃ¡ Ä‘Æ¡n giáº£n, 
                - vÃ­ dá»¥:
                    User-agent: *
                    Disallow: /folder/
                    Allow: /folder/myfile.html
                - giáº£i thÃ­ch:
                    - "User-agent: *" nghÄ©a lÃ  cÃ¡c hÆ°á»›ng dáº«n sau Ã¡p dá»¥ng cho táº¥t cáº£ cÃ¡c web crawlers.
                    - "Disallow: /folder/" ngÄƒn cháº·n cÃ¡c crawlers truy cáº­p vÃ o thÆ° má»¥c chá»©a Ä‘Æ°á»ng dáº«n "/folder/".
                    - "Allow: /folder/myfile.html" cho phÃ©p truy cáº­p vÃ o file cá»¥ thá»ƒ "myfile.html" náº±m trong thÆ° má»¥c bá»‹ cáº¥m kia.
        Kiá»ƒm tra cÆ°á»ng Ä‘á»™ thÆ°á»ng xuyÃªn Ä‘á»ƒ Ä‘áº£m báº£o ráº±ng cáº£ robots.txt vÃ  sitemap váº«n pháº£n Ã¡nh chÃ­nh xÃ¡c cáº¥u trÃºc vÃ  ná»™i dung cá»§a trang web báº¡n.
        Nhá»› lÃ  báº¡n pháº£i thÆ°á»ng xuyÃªn theo dÃµi vÃ  Ä‘iá»u chá»‰nh Ä‘á»ƒ pháº£n Ã¡nh Ä‘Ãºng nháº¥t ná»™i dung vÃ  cáº¥u trÃºc website hiá»‡n táº¡i cá»§a báº¡n nhÃ©!
################################################
HÃ£y giÃºp tÃ´i hiá»ƒu rÃµ vá» emit event trong nodejs nhÃ©?

    Event emitting trong Node.js lÃ  má»™t pháº§n cá»§a mÃ´ hÃ¬nh Event-Driven Architecture, nÆ¡i mÃ  cÃ¡c Ä‘á»‘i tÆ°á»£ng (thÆ°á»ng Ä‘Æ°á»£c gá»i lÃ  emitters)
    phÃ¡t ra cÃ¡c sá»± kiá»‡n hoáº·c tÃ­n hiá»‡u vá» viá»‡c má»™t sá»‘ tráº¡ng thÃ¡i hoáº·c hÃ nh Ä‘á»™ng Ä‘Ã£ xáº£y ra. CÃ¡c Ä‘á»‘i tÆ°á»£ng khÃ¡c, Ä‘Æ°á»£c gá»i lÃ  listeners hoáº·c handlers,
    sau Ä‘Ã³ sáº½ pháº£n há»“i láº¡i vá»›i cÃ¡c sá»± kiá»‡n Ä‘Ã³.

    DÆ°á»›i Ä‘Ã¢y lÃ  má»™t sá»‘ Ä‘iá»ƒm cÆ¡ báº£n vá» emit event trong Node.js:

        1. EventEmitter Class: Node.js cung cáº¥p má»™t module events bao gá»“m EventEmitter class, Ä‘Ã¢y lÃ  ná»n táº£ng cho viá»‡c phÃ¡t vÃ  láº¯ng nghe cÃ¡c sá»± kiá»‡n.
        const EventEmitter = require('events');
        class MyEmitter extends EventEmitter {}

        2. Táº¡o Emitter: Báº¡n táº¡o má»™t emitter báº±ng cÃ¡ch khá»Ÿi táº¡o má»™t instance cá»§a class EventEmitter hoáº·c má»™t subclass má»Ÿ rá»™ng tá»« nÃ³.
        const myEmitter = new MyEmitter();

        3. Emitting Events: Báº¡n phÃ¡t má»™t sá»± kiá»‡n báº±ng phÆ°Æ¡ng thá»©c .emit(), vÃ  Ä‘áº·t tÃªn cho sá»± kiá»‡n. Báº¡n cÅ©ng cÃ³ thá»ƒ truyá»n má»™t sá»‘ dá»¯ liá»‡u lÃ m Ä‘á»‘i sá»‘ cho sá»± kiá»‡n Ä‘Ã³.
        // PhÃ¡t sá»± kiá»‡n 'event'
        myEmitter.emit('event');
        // PhÃ¡t sá»± kiá»‡n 'event' vá»›i Ä‘á»‘i sá»‘
        myEmitter.emit('event', { a: 1, b: 2 });

        4. Listening for Events: Äá»ƒ xá»­ lÃ½ má»™t sá»± kiá»‡n, báº¡n cáº§n Ä‘Äƒng kÃ½ má»™t listener cho sá»± kiá»‡n Ä‘Ã³ sá»­ dá»¥ng phÆ°Æ¡ng thá»©c .on() hoáº·c .addListener().
        // ÄÄƒng kÃ½ má»™t listener cho 'event'
        myEmitter.on('event', (data) => {
        console.log('An event occurred!', data);
        });

        5. Emitter vá»›i Nhiá»u Listeners: Báº¡n cÃ³ thá»ƒ cÃ³ nhiá»u listeners cho cÃ¹ng má»™t sá»± kiá»‡n vÃ  chÃºng sáº½ Ä‘Æ°á»£c thá»±c thi theo thá»© tá»± mÃ  báº¡n Ä‘Äƒng kÃ½.
        myEmitter.on('event', function firstListener() {
        console.log('Helloooo! first listener');
        });
        myEmitter.on('event', function secondListener(arg1, arg2) {
        console.log(event with parameters ${arg1}, ${arg2} in second listener);
        });
        myEmitter.emit('event', 1, 2);

        6. á»¨ng Dá»¥ng cá»§a Event Emitter: Trong Node.js, emit event Ä‘Æ°á»£c sá»­ dá»¥ng rá»™ng rÃ£i - tá»« viá»‡c xá»­ lÃ½ HTTP requests trong express Ä‘áº¿n viá»‡c Ä‘á»c dá»¯ liá»‡u tá»« streams.

        7. Láº¯ng Nghe Sá»± Kiá»‡n Má»™t Láº§n: Sá»­ dá»¥ng .once() thay vÃ¬ .on() Ä‘á»ƒ Ä‘Äƒng kÃ½ má»™t listener cháº¡y má»™t láº§n duy nháº¥t.

        8. XÃ³a Listeners: Báº¡n cÃ³ thá»ƒ gá»¡ bá» cÃ¡c listeners khá»i má»™t emitter sá»­ dá»¥ng .removeListener() hoáº·c .off().
        const callback = (data) => {
        console.log('An event occurred with data:', data);
        };
        myEmitter.on('event', callback);
        // Sau má»™t thá»§ tá»¥c nÃ o Ä‘Ã³
        myEmitter.removeListener('event', callback);

        9. Giá»›i Háº¡n vá» Sá»‘ Listeners: Máº·c Ä‘á»‹nh, má»™t emitter cÃ³ thá»ƒ cÃ³ tá»‘i Ä‘a 10 listeners Ä‘Äƒng kÃ½ cho má»—i sá»± kiá»‡n. Báº¡n cÃ³ thá»ƒ thay Ä‘á»•i giá»›i háº¡n nÃ y sá»­ dá»¥ng .setMaxListeners().

        10. Error Events: Emitter cÅ©ng cÃ³ thá»ƒ phÃ¡t ra cÃ¡c sá»± kiá»‡n error. Náº¿u cÃ³ lá»—i xáº£y ra vÃ  khÃ´ng cÃ³ listener nÃ o cho sá»± kiá»‡n error, á»©ng dá»¥ng sáº½ crash vÃ  in ra má»™t stack trace.

        NhÆ° báº¡n tháº¥y, emit vÃ  listen cho events trong Node.js lÃ  khÃ¡ Ä‘Æ¡n giáº£n nhÆ°ng máº¡nh máº½, cho phÃ©p báº¡n thiáº¿t káº¿ á»©ng dá»¥ng linh hoáº¡t vÃ  dá»… má»Ÿ rá»™ng.