- Node.js treats each file in a Node project as a module that can export values and functions from the file.
- Declare Objects with const
        - Declaring objects with const will prevent any accidental change of type:
            let car = {type:"Fiat", model:"500", color:"white"};
            car = "Fiat";      // Changes object to string

            const car = {type:"Fiat", model:"500", color:"white"};
            car = "Fiat";      // Not possible
            car.newProperty = "newValue"; // it's ok
            car['newProperty1'] = "newValue1"; // it's ok
    - Declare Arrays with const:
        - Declaring arrays with const will prevent any accidential change of type:
            let cars = ["Saab", "Volvo", "BMW"];
            cars = 3;    // Changes array to number

            const cars = ["Saab", "Volvo", "BMW"];
            cars = 3;    // Not possible
            cars.push("newValue") // It's ok
            cars[4] = "Toyota"; // It's ok
#############################################
- Comparison table for CommonJS and ES Modules
    - Module Loading:
        - CommonJS: Synchronous
        - ES Module: Asynchronous
    - Import/Export:
        - CommonJS: 'require'/'exports'
        - ES Module: 'import'/'export'
    - Caching
        - CommonJS: Cached
        - ES Module: Not cached by default
    - Use Case
        - CommonJS: Server-side
        - ES Module: Client-side and server-side
    - Dynamic Import
        - CommonJS: Not supported
        - ES Module: Supported
Node.js module.exports vs. exports. áp dụng nếu sử dụng CommonJS
    - exports và module.exports chứ không phải là export nhé các bạn, export là cho bên ES module.
      Nhiều bạn hay viết thiếu chữ “s” lắm ấy.
      Trong Javascript thì có cái từ khóa export nhưng trong NodeJS thì chưa đâu.
    - Furthermore, you will come across three types of modules in Node.js:
        - Core Modules: These are built-in modules like http, fs, etc.
        - Local Modules: These modules are locally created by the programmer.
        - Third-Party Modules: These modules are available to use after installation
          using NPM(Node Package Manager) like: express, mongoose etc.
    - Cơ chế Wrapping của NodeJS là gì?
        - When we call require in our application, the new module is created.
          Its initial value is an empty object literal {}. Before the referenced module’s code
          is executed, Node.js will wrap it with the module wrapper function. 
          Let's look briefly into the structure of the module wrapper function:
            (function(exports, require, module, __filename, __dirname) { 
                // Module code actually lives in here 
            });
        - Using the module wrapper function, Node.js keeps top-level variables
          (defined with var, const, or let) scoped to the module rather than as the global
          object. It also provides access to the exported module-specific variables for use
          in our application.
        - The variables __filename and __dirname in the module wrapper function contain the
          absolute filename and directory path of the module.
        - Now let's look into module.exports, module.exports is the object reference that gets
          returned when we make require() calls in our application. By module. exports,
          we can get access to module-specific variables that don’t leak out to the global object.
    - module.exports và exports khác nhau như thế nào?
        - Trước hết thì module.exports và exports trỏ tới cùng một Object, là một Object rỗng.
        - Tuy nhiên, chỉ có một thằng module.exports là cái thật sự được export khi mình require nó thôi. 
          Còn thằng exports thì không phải. Nó chỉ là một reference tới thằng module.exports thôi.
            - ví dụ:
                module.exports.name = "Nguyen";
                exports.name = "Nguyen";
                console.log(module.exports); //{ name: 'Nguyen' }
                console.log(exports); //{ name: 'Nguyen' }
                console.log(module.exports === exports); //true
            - Ở đây có thể thấy hai thằng này chỉ thay đổi cái properties của cái Object ban đầu
              (là Object rỗng ban đầu). Nên ở đây, hai thằng này vẫn là cùng một Object.
            - Tuy nhiên, nếu như sửa lại:
                module.exports = {
                    name: "Nguyen"
                };
                exports = {
                    name: "Nguyen"
                };
                console.log(module.exports === exports); // false
            - Hai thằng này là hai cái Object khác nhau, vì mình là assign lại giá trị cho thằng
              exports (Mình dùng dấu =).Kết quả sẽ là false
            - Mình chứng minh thêm như sau:
                - Trong file export.js mình viết: 
                    exports = {
                        name: "Nguyen"
                    };
                - Sau đó, trong file index.js mình viết
                    const object = require("./export");
                    console.log(object);
                - Thì kết quả là {}
            - Vì chỉ là thằng module.exports mới là thằng thật sự được export
              (Và mặc định nó là một Object rỗng). Còn thằng exports thì không.
        - Vậy thì khi nào sử dụng thằng exports?
            - Dùng thằng exports chỉ khi nào mình muốn add thêm một cái properties vào
              cái Object mặc định của nó. Ví dụ như thay vì viết;
                module.exports.x = 1;
                module.exports.y = 2;
                module.exports.z = 3;
            - Thì có thể viết thành như sau cho nó ngắn và tiện hơn.
                exports.x = 1;
                exports.y = 2;
                exports.z = 3;
    - Kết luận:
        - Luôn sử dụng module.exports khi muốn export một cái gì đó.
          Đừng lăn tăn sử dụng exports là gì cho rối rắm hết cả lên.  
##################################
JavaScript Object Rest Properties
    - ECMAScript 2018 added rest properties.
    - This allows us to destruct an object and collect the leftovers onto a new object:
        Example
            let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
            x; // 1
            y; // 2
            z; // { a: 3, b: 4 }
############################################
Arguments javascript dễ hiểu mà sao họ giải thích dài thế
    - Thật ra nó rất dễ hiểu, việc thông qua những ví dụ dưới đây là hiểu rồi. 
      Nhưng đến giờ tôi không biết tại sao có nhiều bài viết giải thích dài dòng đến như vậy. Hãy xem ví dụ:
        function add (num1, num2) {
            // logs [num1, num2] (with their values)
            console.log(arguments); [num1, num2]
            // Lấy ra param đầu tiên 
            console.log(arguments[0]); // num1
            // Lấy ra param thứ 2
            console.log(arguments[1]); // num2
            // ...
        }
    - Ví dụ này chúng tôi tạo một Regular Function. Đừng nói với tôi Regular Function là gì? đấy nhé. Vậy thôi đơn giản gọn nhẹ,
      arguments giúp chúng ta lấy được tham số truyền vào một cách dễ dàng. Ở đây có ý kiến cho rằng vậy "khác gì cách lấy tham số đâu?" 
    - OK, ví dụ tiếp theo sẽ khác đấy.
        function add () {
            // Set biến tổng
            let total = 0;
            // Cộng đồn mỗi params
            Array.from(arguments).forEach(function (num) {
                total += num;
            });
            // Return to the total
            return total;
        }
    - Tiếp theo chúng ta sử dụng ví dụ này như sau:
        // returns 0
        add();
        // returns 4
        add(4);
        // returns 36
        add(4, 2, 11, 19);
    - Có gì khác chưa? Khác đúng không? Điều này đặc biệt hữu ích nếu bạn muốn cho phép một số lượng không giới hạn các đối số được chuyển vào hàm của bạn.
    - Arguments javascript sử dụng nên chú ý
    - Khi sử dụng Arguments trong javascript cũng nên chú ý một điều cũng hơi quan trọng đó là arguments
      giống như một Array nhưng nó không thực sự là một Array. Nếu nó là một Array thì tất cả 10 method của Array đều có thể sử dụng được. 

    - Nhưng ví dụ trên thì chúng ta phải nhờ đến người anh em Array.from trước sau đó mới sử dụng forEach(). 
      Vậy Arguments thực sự là gì? Arguments có thể nói chính là Array-like.
############################################
const
    The const declaration declares block-scoped local variables.
    The value of a constant can't be changed through reassignment using the assignment operator, but if a constant is an object,
    its properties can be added, updated, or removed.
    - const in objects and arrays
        - const also works on objects and arrays. Attempting to overwrite the object throws an error "Assignment to constant variable".
            - example: 
                - it is throw an error:
                    //object
                    const MY_OBJECT = { key: "value" };
                    MY_OBJECT = { OTHER_KEY: "value" };
                    //array
                    const MY_ARRAY = [];
                    MY_ARRAY = ["B"];
                - However, object keys are not protected, so the following statement is executed without problem.
                    MY_OBJECT.key = "otherValue";
                - Still, it's possible to push items into the array and thus mutate it.
                    MY_ARRAY.push("A"); // ["A"]
        - Declaration with destructuring
            - The left-hand side of each = can also be a binding pattern. This allows creating multiple variables at once.
                const result = /(a+)(b+)(c+)/.exec("aaabcc");
                const [, a, b, c] = result;
                console.log(a, b, c); // "aaa" "b" "cc"
            - But if we change the values of the variables above, it throw an error: Uncaught TypeError: Assignment to constant variable.
#############################################
Giải thích về Destructuring, Rest Parameters, và Spread Syntax trong javascript
    - Destructuring javascript là gì?
        - Destructuring là một cú pháp cho phép bạn gán các thuộc tính của một Object hoặc một Array. 
          Điều này có thể làm giảm đáng kể các dòng mã cần thiết để thao tác dữ liệu trong các cấu trúc này. 
          Có hai loại Destructuring: Destructuring Objects và Destructuring Arrays
            - Destructuring Objects:
                - Destructuring Objects cho phép bạn tạo ra một hay nhiều  new variables  sử dụng những property của một Objects. Xem ví dụ dưới đây:
                    - example: 
                        const note = {
                            id: 1,
                            website: 'anonystick.com',
                            date: '17/07/2014',
                        }
                    - Theo cách truyền thống thì chúng ta sẽ lấy ra những giá trị như cú pháp sau:
                        const id = note.id
                        const website = note.website
                        const date = note.date

                        console.log(id)
                        console.log(website)
                        console.log(date)
                    - Nhưng với việc sử dụng object destructuring chỉ với một dòng code ( Thủ thuật viết một dòng code ),
                      chúng ta có thể get được những giá trị ấy miễn là trùng tên của thuộc tính trong object là được:
                        // Destructure properties into variables
                        const { id, website, date } = note

                        console.log(id)
                        console.log(website)
                        console.log(date)
            - Destructuring Arrays:
                - Array destructuring cho phép bạn tạo ra một new variables bằng cách sử dụng giá trị mỗi index của Array. 
                  Xem ví dụ dưới đây cho nó dễ hiểu, chứ nói vậy chả hiểu đâu. 
                  Ta có một Array là thông tin về trang "blog javascript" được tạo ngày
                    - example: 
                        const date = ['2014', '17', '07']
                    - Như ở Object thì ta lần lượt lấy giá trị của mỗi item theo index
                        // Create variables from the Array items
                        const year = date[0]
                        const month = date[1]
                        const day = date[2]
                    - Nhưng giờ đây với việc sử dụng Array Destructuring thì công việc sẽ trở nên dế dàng hơn nhiều
                        // Destructure Array values into variables
                        const [year, month, day] = date

                        console.log(year) // 2014
                        console.log(month) // 17
                        console.log(day) // 07
    - Spread operator là gì?
        - Spread operator là ba dấu chấm ( ...), có thể chuyển đổi một mảng thành một chuỗi các tham số được phân tách bằng dấu phẩy.
          Nói cho dễ hiểu, nó giống như một cái xương và một cái xương sườn vậy, chia nhỏ một phần tử lớn thành những phần tử nhỏ riêng lẻ.
        - Nói về Spread tips javascript cũng đã có rất nhiều bài viết liên quan đến tính năng này. Spread syntax hay còn gọi là three dot (...)
          là một bổ sung hữu ích khác cho JavaScript để làm việc với các Arrays, Objects và các function calls. 
        - Hơn nữa Spread có thể tao ra một cấu trúc dữ liệu shallow copy để tăng tính thao tác dữ liệu. 
          Cũng giống như destructuring thì Spread cũng làm việc nhiều với Arrays và Objects.
        - Spread with Arrays:
            - Ví dụ trường hợp thức tế thì ta có thể merge array sử dụng concat.
                // Create an Array
                const tools = ['hammer', 'screwdriver']
                const otherTools = ['wrench', 'saw']

                // Concatenate tools and otherTools together
                const allTools = tools.concat(otherTools)

                console.log(allTools);

                //(4) [
                "hammer",
                "screwdriver",
                "wrench",
                "saw"
                ]
            - Nhưng giờ đây đã khác xưa rất nhiều rồi, hãy xem đây khi sử dụng Spread systax.
                // Unpack the tools Array into the allTools Array
                const allTools = [...tools, ...otherTools]
                console.log(allTools)
            - Còn rất nhiều thứ rất hay đang chờ đón bạn, chút nữa sẽ cung cấp đanh cho những ai đủ kiên nhẫn đọc hết bài viết này. 
                const ocean = ['🐙', '🦀'];
                const aquarium = [...ocean, '🐡']; // Add a single value
                const sushi = [...ocean, '🐡', '🍚']; // Add multiple values
                aquarium; // ['🐙', '🦀', '🐡']
                sushi; // ['🐙', '🦀', '🐡', '🍚']
                // Original Array Not Affected
                ocean; // ['🐙', '🦀']
        - Spread with Objects:
            - Khi sử dụng Spread thì chúng ta có thể copy và update một object như những gì mà Object.assign() đã làm
            - // Create an Object and a copied Object with Object.assign()
                const originalObject = { enabled: true, darkMode: false }
                const secondObject = Object.assign({}, originalObject)
                console.log(secondObject);//{enabled: true, darkMode: false}
            - Sử dụng Spread syntax thì sao? ez game.
                // Create an object and a copied object with spread
                const originalObject = { enabled: true, darkMode: false }
                const secondObject = { ...originalObject }
                console.log(secondObject);//{enabled: true, darkMode: false}
            - Spread with Function Calls
                - Giả sử chúng ta có một function như thế này
                    // Create a function to multiply three items
                    function multiply(a, b, c) {
                        return a * b * c
                    }
                - Nếu bình thường thì sao, thì add từng paramsx zô chứ sao:
                    multiply(1, 2, 3) ;// 6
                - Nhưng khi sử dụng Spread trong function calls thì rất đơn giản
                    const numbers = [1, 2, 3]
                    multiply(...numbers);//6
    - Rest Parameters là gì?
        - Tính năng cuối cùng bạn sẽ tìm hiểu trong bài viết này đó là Rest Parameters. Cú pháp này giống như Spread Syntax (...) nhưng có tác dụng ngược lại.
          Ví dụ Ví dụ, trong hàm restTest, nếu chúng ta muốn args là một mảng bao gồm một số lượng đối số không xác định, chúng ta có thể có:
            function restTest(...args) {
                console.log(args)
            }
            restTest(1, 2, 3, 4, 5, 6);// [1, 2, 3, 4, 5, 6]
    - Và đây là một bài viết về Rest Parameters và Spread Syntax dành cho những bạn kiên nhẫn đọc tới đây. 
      Ở bài viết này thì mọi điều sẽ được sáng tỏ, bạn sẽ phân biệt được giữa Rest Parameters và Spread Syntax. Và khi nào sử dụng chúng.

#############################################
- The Nullish Coalescing Operator (??)
    - The ?? operator returns the first argument if it is not nullish (null or undefined). 
      Otherwise it returns the second argument.
        - Example:
            let name = null;
            let text = "missing";
            let result = name ?? text;
            -> result: missing
- The Optional Chaining Operator (?.):
    - The ?. operator returns undefined if an object is undefined or null (instead of throwing an error).
    - Example:
        // Create an object:
        const car = {type:"Fiat", model:"500", color:"white"};
        // Ask for car name:
        document.getElementById("demo").innerHTML = car?.name;
        -> result: undefined
#############################################
JavaScript Object Properties
    - Accessing JavaScript Properties:
        - The syntax for accessing the property of an object is:
            - objectName.property      // person.age
            or
            - objectName["property"]   // person["age"]
            or
            - objectName[expression]   // x = "age"; person[x]
        - The expression must evaluate to a property name.
##############################################
- JavaScript supports different kinds of loops:
    - for - loops through a block of code a number of times
    - for/in - loops through the properties of an object
    - for/of - loops through the values of an iterable object
    - while - loops through a block of code while a specified condition is true
    - do/while - also loops through a block of code while a specified condition is true
###################################################
- JavaScript Array Iteration
    - Array forEach()
        - The forEach() method calls a function for each element in an array.
        - The forEach() method is not executed for empty elements.
        - Syntax: array.forEach(function(currentValue, index, arr), thisValue)
        - Parameters:
            function(): Required. A function to run for each array element.
            currentValue: Required.The value of the current element.
            index: Optional.The index of the current element.
            arr: Optional. The array of the current element.
            thisValue: Optional. Default undefined. A value passed to the function as its this value.
        - Return Value: undefined
        - example 1:
            let sum = 0;
            const numbers = [65, 44, 12, 4];
            numbers.forEach(myFunction);

            function myFunction(item) {
                sum += item;
            }
        - example 2:
            const numbers = [65, 44, 12, 4];
            numbers.forEach(myFunction)

            function myFunction(item, index, arr) {
                arr[index] = item * 10;
            }
    - Array map():
        - The map() method creates a new array by performing a function on each array element.
        - The map() method does not execute the function for array elements without values.
        - The map() method does not change the original array.
        - Example:
            const numbers1 = [45, 4, 9, 16, 25];
            const numbers2 = numbers1.map(myFunction);

            function myFunction(value, index, array) {
                return value * 2;
            }
        - Note that the function takes 3 arguments:
            - The item value
            - The item index
            - The array itself
    - Array filter():
        - The filter() method creates a new array with array elements that pass a test.
        - This example creates a new array from elements with a value larger than 18:
        - Example:
            const numbers = [45, 4, 9, 16, 25];
            const over18 = numbers.filter(myFunction);

            function myFunction(value, index, array) {
                return value > 18;
            }
        - Note that the function takes 3 arguments:
            - The item value
            - The item index
            - The array itself
    - Array reduce():
        - The reduce() method runs a function on each array element to produce (reduce it to) a single value.
        - The reduce() method works from left-to-right in the array. See also reduceRight().
        - The reduce() method does not reduce the original array.
        - This example finds the sum of all numbers in an array:
        - Example
            const numbers = [45, 4, 9, 16, 25];
            let sum = numbers.reduce(myFunction);

            function myFunction(total, value, index, array) {
                return total + value;
            }
        - Note that the function takes 4 arguments:
            - The total (the initial value / previously returned value)
            - The item value
            - The item index
            - The array itself
    - Array every():
        - The every() method checks if all array values pass a test.
        - This example checks if all array values are larger than 18:
        - Example
            const numbers = [45, 4, 9, 16, 25];
            let allOver18 = numbers.every(myFunction);

            function myFunction(value, index, array) {
                return value > 18;
            }
            -> result: All over 18 is false
        - Note that the function takes 3 arguments:
            - The item value
            - The item index
            - The array itself
    - Array some():
        - The some() method checks if some array values pass a test.
        - This example checks if some array values are larger than 18:
        - Example
            const numbers = [45, 4, 9, 16, 25];
            let someOver18 = numbers.some(myFunction);

            function myFunction(value, index, array) {
                return value > 18;
            }
            -> result: Some over 18 is true
        - Note that the function takes 3 arguments:
            - The item value
            - The item index
            - The array itself
    - Array Spread (...):
        - The ... operator expands an iterable (like an array) into more elements:
        - Example:
            const q1 = ["Jan", "Feb", "Mar"];
            const q2 = ["Apr", "May", "Jun"];
            const q3 = ["Jul", "Aug", "Sep"];
            const q4 = ["Oct", "Nov", "May"];

            const year = [...q1, ...q2, ...q3, ...q4];
##############################################
- What is this?
        - In JavaScript, the this keyword refers to an object.
        - Which object depends on how this is being invoked (used or called).
        - The this keyword refers to different objects depending on how it is used:
            - In an object method, this refers to the object.
            - Alone, this refers to the global object.
            - In a function, this refers to the global object.
            - In a function, in strict mode, this is undefined.
            - In an event, this refers to the element that received the event.
            - Methods like call(), apply(), and bind() can refer this to any object.
            - this is not a variable. It is a keyword. You cannot change the value of this.
################################################
#####################################################
Object.defineProperties()
    - The Object.defineProperties() static method defines new or modifies existing properties directly on an object, returning the object.
        const object1 = {};
        Object.defineProperties(object1, {
        property1: {
            value: 42,
            writable: true,
        },
        property2: {},
        });
        console.log(object1.property1);
        // Expected output: 42
    - Syntax:
        Object.defineProperties(obj, props)
        - Parameters:
            - obj
                - The object on which to define or modify properties.
            - props:
                - An object whose keys represent the names of properties to be defined or
                  modified and whose values are objects describing those properties.
                  Each value in props must be either a data descriptor or an accessor descriptor;
                  it cannot be both (see Object.defineProperty() for more details).
                - Data descriptors and accessor descriptors may optionally contain the following keys:
                    - configurable: 
                        - true if and only if the type of this property descriptor may be changed
                          and if the property may be deleted from the corresponding object. Defaults to false.
                    - enumerable:
                        - true if and only if this property shows up during enumeration
                          of the properties on the corresponding object. Defaults to false.
                - A data descriptor also has the following optional keys:
                    - value
                        - The value associated with the property. 
                          Can be any valid JavaScript value (number, object, function, etc.). 
                          Defaults to undefined.
                    - writable
                        - true if and only if the value associated with the property may be changed
                          with an assignment operator. Defaults to false.
                - An accessor descriptor also has the following optional keys:
                    - get
                        - A function which serves as a getter for the property, or undefined if there is no getter.
                          The function's return value will be used as the value of the property. 
                          Defaults to undefined.

                    - set
                        - A function which serves as a setter for the property, or undefined if there is no setter.
                          The function will receive as its only argument the new value being assigned to the property. 
                          Defaults to undefined.
                - If a descriptor has neither of value, writable, get and set keys, it is treated as a data descriptor.
                  If a descriptor has both value or writable and get or set keys, an exception is thrown.
                - Return value:
                    - The object that was passed to the function.
                        const obj = {};
                        Object.defineProperties(obj, {
                            property1: {
                                value: true,
                                writable: true,
                            },
                            property2: {
                                value: "Hello",
                                writable: false,
                            },
                            // etc. etc.
                        });
#####################################################
Object.defineProperty()
    - The Object.defineProperty() static method defines a new property directly on an object, 
      or modifies an existing property on an object, and returns the object.
        const object1 = {};
        Object.defineProperty(object1, 'property1', {
            value: 42,
            writable: false,
        });
        object1.property1 = 77;
        // Throws an error in strict mode
        console.log(object1.property1);
        // Expected output: 42
    - Syntax:
        Object.defineProperty(obj, prop, descriptor)
        - Parameters:
            - obj
                The object on which to define the property.
            - prop
                A string or Symbol specifying the key of the property to be defined or modified.
            - descriptor
                The descriptor for the property being defined or modified.
    - Return value:
        - The object that was passed to the function, with the specified property added or modified.
    - Description:
        - Object.defineProperty() allows a precise addition to or modification of a property on an object.
          Normal property addition through assignment creates properties which show up during
          property enumeration (for...in, Object.keys(), etc.), whose values may be changed and which may be deleted.
          This method allows these extra details to be changed from their defaults. 
          By default, properties added using Object.defineProperty() are not writable, 
          not enumerable, and not configurable. In addition, Object.defineProperty() uses the [[DefineOwnProperty]] internal method,
          instead of [[Set]], so it does not invoke setters, even when the property is already present.
        - Property descriptors present in objects come in two main flavors: 
          data descriptors and accessor descriptors. A data descriptor is a property with a value that may or may not be writable.
          An accessor descriptor is a property described by a getter-setter pair of functions. 
          A descriptor must be one of these two flavors; it cannot be both.
        - Both data and accessor descriptors are objects. They share the following optional keys
          (please note: the defaults mentioned here are in the case of defining properties using Object.defineProperty()):
            - configurable:
                - the type of this property cannot be changed between data property and accessor property, and
                - the property may not be deleted, and
                - other attributes of its descriptor cannot be changed (however, if it's a data descriptor with writable: true,
                  the value can be changed, and writable can be changed to false).
                - Defaults to false.
            - enumerable:
                - true if and only if this property shows up during enumeration of the properties on the corresponding object. 
                - Defaults to false.
        - A data descriptor also has the following optional keys:
            - value
                - The value associated with the property. Can be any valid JavaScript value (number, object, function, etc.). 
                  Defaults to undefined.
            - writable
                - true if the value associated with the property may be changed with an assignment operator. 
                  Defaults to false.
        - An accessor descriptor also has the following optional keys:
            - get
                - A function which serves as a getter for the property, or undefined if there is no getter.
                  When the property is accessed, this function is called without arguments and with this set
                  to the object through which the property is accessed (this may not be the object on which the property is defined due to inheritance).
                  The return value will be used as the value of the property. 
                - Defaults to undefined.
            - set
                - A function which serves as a setter for the property, or undefined if there is no setter.
                  When the property is assigned, this function is called with one argument (the value being assigned to the property)
                  and with this set to the object through which the property is assigned. 
                - Defaults to undefined.
        - If a descriptor doesn't have any of the value, writable, get, and set keys, it is treated as a data descriptor. 
          If a descriptor has both [value or writable] and [get or set] keys, an exception is thrown.
        - These attributes are not necessarily the descriptor's own properties. 
          Inherited properties will be considered as well. In order to ensure these defaults are
          preserved, you might freeze existing objects in the descriptor object's prototype chain upfront,
          specify all options explicitly, or create a null-prototype object.
        - Creating a property
            - example:
                const o = {}; // Creates a new object

                // Example of an object property added
                // with defineProperty with a data property descriptor
                Object.defineProperty(o, "a", {
                    value: 37,
                    writable: true,
                    enumerable: true,
                    configurable: true,
                });
                // 'a' property exists in the o object and its value is 37
        - Modifying a property
            - Writable attribute:
                - When the writable property attribute is false, the property is said to be "non-writable". 
                  It cannot be reassigned. Trying to write to a non-writable property doesn't change it
                  and results in an error in strict mode.
                - example:
                    const o = {}; // Creates a new object
                    Object.defineProperty(o, "a", {
                        value: 37,
                        writable: false,
                    });
                    console.log(o.a); // 37
                    o.a = 25; // No error thrown
                    // (it would throw in strict mode,
                    // even if the value had been the same)
                    console.log(o.a); // 37; the assignment didn't work
                    // strict mode
                    (() => {
                        "use strict";
                        const o = {};
                        Object.defineProperty(o, "b", {
                            value: 2,
                            writable: false,
                        });
                        o.b = 3; // throws TypeError: "b" is read-only
                        return o.b; // returns 2 without the line above
                    })();
#################################################
JavaScript Object Prototypes
    - All JavaScript objects inherit properties and methods from a prototype.
    - Prototype Inheritance
        - All JavaScript objects inherit properties and methods from a prototype:
            - Date objects inherit from Date.prototype
            - Array objects inherit from Array.prototype
            - Person objects inherit from Person.prototype     
        - The Object.prototype is on the top of the prototype inheritance chain:
        - Date objects, Array objects, and Person objects inherit from Object.prototype.  
    - Adding Properties and Methods to Objects
        - Sometimes you want to add new properties (or methods) to all existing objects of a given type.
        - Sometimes you want to add new properties (or methods) to an object constructor. 
    - Using the prototype Property:
        - The JavaScript prototype property allows you to add new properties to object constructors:
            function Person(first, last, age, eyecolor) {
                this.firstName = first;
                this.lastName = last;
                this.age = age;
                this.eyeColor = eyecolor;
            }
            Person.prototype.nationality = "English";
        - The JavaScript prototype property also allows you to add new methods to objects constructors:
            function Person(first, last, age, eyecolor) {
                this.firstName = first;
                this.lastName = last;
                this.age = age;
                this.eyeColor = eyecolor;
            }
            Person.prototype.name = function() {
                return this.firstName + " " + this.lastName;
            };
    - Only modify your own prototypes. Never modify the prototypes of standard JavaScript objects.
####################################################
JavaScript Modules
    - JavaScript modules allow you to break up your code into separate files.
    - This makes it easier to maintain a code-base.
    - Modules are imported from external files with the import statement.
    - Modules also rely on type="module" in the <script> tag.
        <script type="module">
            import message from "./message.js";
        </script>
    - Export:
        - Modules with functions or variables can be stored in any external file.
        - There are two types of exports: Named Exports and Default Exports.

        - Named Exports:
            - Let us create a file named person.js, and fill it with the things we want to export.
            - You can create named exports two ways. In-line individually, or all at once at the bottom.
            - In-line individually:
                - person.js:
                    export const name = "Jesse";
                    export const age = 40;
            - All at once at the bottom:
                - person.js:
                    const name = "Jesse";
                    const age = 40;
                    export {name, age};
        - Default Exports:
            - Let us create another file, named message.js, and use it for demonstrating default export.
            - You can only have one default export in a file.
                - message.js
                    const message = () => {
                        const name = "Jesse";
                        const age = 40;
                        return name + ' is ' + age + 'years old.';
                    };
                    export default message;
    - Import:
        - You can import modules into a file in two ways, based on if they are named exports or default exports.
        - Named exports are constructed using curly braces. Default exports are not.
        - Import from named exports:
            - Import named exports from the file person.js:
                import { name, age } from "./person.js";
        - Import from default exports:
            - Import a default export from the file message.js:
                import message from "./message.js";
    - Modules only work with the HTTP(s) protocol.
    - A web-page opened via the file:// protocol cannot use import / export.
#######################################
JavaScript Function call()
    - Method Reuse:
        - With the call() method, you can write a method that can be used on different objects.
    - All Functions are Methods:
        - In JavaScript all functions are object methods.
        - If a function is not a method of a JavaScript object, it is a function of the global object (see previous chapter).
        - The example below creates an object with 3 properties, firstName, lastName, fullName.
        - Example
            const person = {
                firstName:"John",
                lastName: "Doe",
                fullName: function () {
                    return this.firstName + " " + this.lastName;
                }
            }
            // This will return "John Doe":
            person.fullName();
        - In the example above, this refers to the person object.
        - this.firstName means the firstName property of this.
        - Same as: this.firstName means the firstName property of person.
    - The JavaScript call() Method:
        - The call() method is a predefined JavaScript method.
        - It can be used to invoke (call) a method with an owner object as an argument (parameter).
        - With call(), an object can use a method belonging to another object.
        - This example calls the fullName method of person, using it on person1:
            const person = {
                fullName: function() {
                    return this.firstName + " " + this.lastName;
                }
            }
            const person1 = {
                firstName:"John",
                lastName: "Doe"
            }
            const person2 = {
                firstName:"Mary",
                lastName: "Doe"
            }
            // This will return "John Doe":
            person.fullName.call(person1);
        - This example calls the fullName method of person, using it on person2:
            const person = {
                fullName: function() {
                    return this.firstName + " " + this.lastName;
                }
            }
            const person1 = {
                firstName:"John",
                lastName: "Doe"
            }
            const person2 = {
                firstName:"Mary",
                lastName: "Doe"
            }
            // This will return "Mary Doe"
            person.fullName.call(person2);
        - The call() Method with Arguments:
            - The call() method can accept arguments:
                const person = {
                    fullName: function(city, country) {
                        return this.firstName + " " + this.lastName + "," + city + "," + country;
                    }
                }
                const person1 = {
                    firstName:"John",
                    lastName: "Doe"
                }
                person.fullName.call(person1, "Oslo", "Norway");
#############################################
JavaScript Function apply()
    - Method Reuse
        - With the apply() method, you can write a method that can be used on different objects.
    - The JavaScript apply() Method
        - The apply() method is similar to the call() method (previous chapter).
        - In this example the fullName method of person is applied on person1:
            const person = {
                fullName: function() {
                    return this.firstName + " " + this.lastName;
                }
            }
            const person1 = {
                firstName: "Mary",
                lastName: "Doe"
            }
            // This will return "Mary Doe":
            person.fullName.apply(person1);
    - The Difference Between call() and apply()
        - The call() method takes arguments separately.
        - The apply() method takes arguments as an array.
        - The apply() method is very handy if you want to use an array instead of an argument list.
    - The apply() Method with Arguments:
        - The apply() method accepts arguments in an array:
            const person = {
                fullName: function(city, country) {
                    return this.firstName + " " + this.lastName + "," + city + "," + country;
                }
            }
            const person1 = {
                firstName:"John",
                lastName: "Doe"
            }
            person.fullName.apply(person1, ["Oslo", "Norway"]);
        - Compared with the call() method:
            const person = {
                fullName: function(city, country) {
                    return this.firstName + " " + this.lastName + "," + city + "," + country;
                }
            }
            const person1 = {
                firstName:"John",
                lastName: "Doe"
            }
            person.fullName.call(person1, "Oslo", "Norway");
######################################
JavaScript Function bind()
    - Function Borrowing
        - With the bind() method, an object can borrow a method from another object.
        - The example below creates 2 objects (person and member).
        - The member object borrows the fullname method from the person object:
            const person = {
                firstName:"John",
                lastName: "Doe",
                fullName: function () {
                    return this.firstName + " " + this.lastName;
                }
            }
            const member = {
                firstName:"Hege",
                lastName: "Nilsen",
            }
            let fullName = person.fullName.bind(member);
    - Preserving this:
        - Sometimes the bind() method has to be used to prevent losing this.
        - In the following example, the person object has a display method. In the display method, this refers to the person object:
            const person = {
                firstName:"John",
                lastName: "Doe",
                display: function () {
                    let x = document.getElementById("demo");
                    x.innerHTML = this.firstName + " " + this.lastName;
                }
            }
            person.display();
        - When a function is used as a callback, this is lost.
        - This example will try to display the person name after 3 seconds, but it will display undefined instead:
            const person = {
                firstName:"John",
                lastName: "Doe",
                display: function () {
                    let x = document.getElementById("demo");
                    x.innerHTML = this.firstName + " " + this.lastName;
                }
            }
            setTimeout(person.display, 3000);
            -> result: undefined undefined
        - The bind() method solves this problem.
        - In the following example, the bind() method is used to bind person.display to person.
        - This example will display the person name after 3 seconds:
            const person = {
                firstName:"John",
                lastName: "Doe",
                display: function () {
                    let x = document.getElementById("demo");
                    x.innerHTML = this.firstName + " " + this.lastName;
                }
            }

            let display = person.display.bind(person);
            setTimeout(display, 3000);
######################################
The JavaScript this Keyword:
    -Example
        const person = {
            firstName: "John",
            lastName : "Doe",
            id       : 5566,
            fullName : function() {
                return this.firstName + " " + this.lastName;
            }
        };
    - What is this?
        - In JavaScript, the this keyword refers to an object.
        - Which object depends on how this is being invoked (used or called).
        - The this keyword refers to different objects depending on how it is used:
            - In an object method, this refers to the object.
            - Alone, this refers to the global object.
            - In a function, this refers to the global object.
            - In a function, in strict mode, this is undefined.
            - In an event, this refers to the element that received the event.
            - Methods like call(), apply(), and bind() can refer this to any object.
            - this is not a variable. It is a keyword. You cannot change the value of this.
    - this in a Method:
        - When used in an object method, this refers to the object.
        - In the example on top of this page, this refers to the person object.
        - Because the fullName method is a method of the person object.
    - this Alone:
        - When used alone, this refers to the global object.
        - Because this is running in the global scope.
        - In a browser window the global object is [object Window]:
            let x = this;
        - In strict mode, when used alone, this also refers to the global object:
            "use strict";
            let x = this;
    - this in a Function (Default):
        - In a function, the global object is the default binding for this.
        - In a browser window the global object is [object Window]:
            function myFunction() {
                return this;
            }
    - this in a Function (Strict):
        - JavaScript strict mode does not allow default binding.
        - So, when used in a function, in strict mode, this is undefined.
    - this in Event Handlers:
        - In HTML event handlers, this refers to the HTML element that received the event:
            ex: <button onclick="this.style.display='none'">Click to Remove Me!</button>
    - Object Method Binding:
        - In these examples, this is the person object:
            const person = {
                firstName  : "John",
                lastName   : "Doe",
                id         : 5566,
                myFunction : function() {
                    return this;
                }
            };

            const person = {
                firstName: "John",
                lastName : "Doe",
                id       : 5566,
                fullName : function() {
                    return this.firstName + " " + this.lastName;
                }
            };
            i.e. this.firstName is the firstName property of this (the person object).
    - Explicit Function Binding:
        - The call() and apply() methods are predefined JavaScript methods.
        - They can both be used to call an object method with another object as argument.
        - The example below calls person1.fullName with person2 as an argument,
          this refers to person2, even if fullName is a method of person1:
            const person1 = {
                fullName: function() {
                    return this.firstName + " " + this.lastName;
                }
            }
            const person2 = {
                firstName:"John",
                lastName: "Doe",
            }
            // Return "John Doe"; object person2 call method fullName
            person1.fullName.call(person2);
    - Function Borrowing:
        - With the bind() method, an object can borrow a method from another object.
        - This example creates 2 objects (person and member).
        - The member object borrows the fullname method from the person object:
            const person = {
                firstName:"John",
                lastName: "Doe",
                fullName: function () {
                    return this.firstName + " " + this.lastName;
                }
            }
            const member = {
                firstName:"Hege",
                lastName: "Nilsen",
            }
            let fullName = person.fullName.bind(member);
####################################
ES6 Arrow Functions:
    - Block body thì => return keyword cần có
    - Concise(dạng ngắn gọn) body thì => return keyword là implied và không cần thiết
        Example A: Normal Function
        const sayHi = function(name) {
            return name
        }

        Example B: Arrow Function with Explicit Return
        // Multi-line
        const sayHi = (name) => {
            return name
        }

        // Single-line
        const sayHi = (name) => { return name }

        Example C: Arrow Function with Implicit Return
        // Single-line
        const sayHi = (name) => name

        // Multi-line
        const sayHi = (name) => (
            name
        )
    - Returning Objects:
        - const me = () => { name: "samantha" };
            me(); // undefined 😱
        - const me = () => ({ name: "samantha" });
            me(); // { name: "samantha" }
##################################
ExpressJS

    - ví dụ:
        import express from "express";
        import mongoose from "mongoose";
        import dotenv from "dotenv";
        import userRoute from "./routes/user.route.js";
        import gigRoute from "./routes/gig.route.js";
        import orderRoute from "./routes/order.route.js";
        import conversationRoute from "./routes/conversation.route.js";
        import messageRoute from "./routes/message.route.js";
        import reviewRoute from "./routes/review.route.js";
        import authRoute from "./routes/auth.route.js";
        import uploadRoute from "./routes/upload.route.js";
        import cookieParser from "cookie-parser";
        import cors from "cors";

        const app = express();
        mongoose.set("strictQuery", true);
        dotenv.config();
        app.use(express.urlencoded({
            extended: true
        }))

        const connect = async () => {
            try {
                await mongoose.connect(process.env.MONGO);
                console.log("Connected to mongoDB!");
            } catch (error) {
                console.log(error.message);
            }
        };

        // cần sử dụng thư viện này vì nếu ta gọi từ ứng bên client chạy react đến api, sẽ gặp lỗi 
        // cors policy vì chúng ta đang cố truy cập đến api từ một nơi khác. thư viện này cho phép ta
        // nói với ứng dụng là cho phép domain này truy cập vào api của chúng ta
        app.use(cors({ origin: "http://localhost:5173", credentials: true }));

        app.use(express.json());
        app.use(cookieParser());

        app.use("/api/auth", authRoute);
        app.use("/api/users", userRoute);
        app.use("/api/gigs", gigRoute);
        app.use("/api/orders", orderRoute);
        app.use("/api/conversations", conversationRoute);
        app.use("/api/messages", messageRoute);
        app.use("/api/reviews", reviewRoute);
        app.use("/api/upload", uploadRoute);

        app.use((err, req, res, next) => {
            const errorStatus = err.status || 500;
            const errorMessage = err.message || "Something went wrong";
            return res.status(errorStatus).send(errorMessage);
        });
        app.listen(8000, () => {
            connect();
            console.log("Backend server is running");
        });
- Công dụng của hàm app.use:
    - Đăng ký middleware: Hàm app.use được sử dụng để đăng ký middleware với ứng dụng Express. 
      Middleware là các hàm được sử dụng để xử lý các yêu cầu HTTP trước khi chúng được chuyển đến các tuyến đường.
    - Xử lý các yêu cầu: Middleware có thể được sử dụng để thực hiện các tác vụ như:
        - Xác thực và ủy quyền
        - Phân tích dữ liệu yêu cầu
        - Ghi nhật ký
        - Xử lý lỗi
    - Cấu hình linh hoạt: Hàm app.use cho phép bạn cấu hình ứng dụng Express theo cách linh hoạt. 
      Bạn có thể đăng ký middleware cho các tuyến đường cụ thể hoặc cho toàn bộ ứng dụng.

- Thứ tự thực hiện middleware và số lượng đối số trong hàm callback
    - Thứ tự thực hiện middleware:
        - Middleware được thực thi theo thứ tự được khai báo trong mã.
        - Middleware được đặt trước sẽ được thực thi trước, sau đó đến các middleware được đặt sau.
- Số lượng đối số trong hàm callback:
    - Số lượng đối số trong hàm callback của middleware không ảnh hưởng đến thứ tự thực hiện.
    - Nó chỉ ảnh hưởng đến chức năng của middleware.
- Ví dụ:
    app.use((req, res, next) => {
    console.log('Middleware 1');
    next();
    });

    app.use((req, res, next) => {
    console.log('Middleware 2');
    next();
    });

    app.get('/', (req, res) => {
    res.send('Hello World!');
    });

    app.listen(3000);
- Trong ví dụ này, cả hai middleware đều có 3 đối số: req, res và next.
- Tuy nhiên, middleware 1 sẽ được thực thi trước middleware 2 vì nó được khai báo trước.

- Bảng sau đây tóm tắt số lượng đối số phổ biến trong hàm callback của middleware và chức năng của chúng:

    Số lượng đối    số	Chức năng
    4	            Middleware xử lý lỗi
    3	            Middleware thông thường
    2	            Middleware chỉ xử lý request và response

- Lưu ý:
    - Bạn có thể sử dụng bất kỳ số lượng đối số nào trong hàm callback của middleware.
    - Tuy nhiên, 3 đối số là phổ biến nhất.
    - Middleware xử lý lỗi phải có 4 đối số.

Kết luận:

    - Thứ tự thực hiện middleware được xác định bởi thứ tự khai báo trong mã, không phải bởi số lượng đối số trong hàm callback.
      Số lượng đối số chỉ ảnh hưởng đến chức năng của middleware.

- Hàm app.listen(3000); được đặt ở cuối cùng để đảm bảo rằng tất cả các middleware và tuyến đường đã được định nghĩa trước
  khi máy chủ Express bắt đầu lắng nghe các yêu cầu.
#################################
- Hàm next
    Hàm next được sử dụng trong middleware để chuyển tiếp yêu cầu đến middleware tiếp theo trong chuỗi.
    Nó hoạt động như một cờ hiệu để cho biết middleware hiện tại đã hoàn tất việc xử lý yêu cầu và middleware tiếp theo có thể bắt đầu.

- Cách thức hoạt động:
    - Khi một middleware được gọi, nó có thể thực hiện một số thao tác với yêu cầu và phản hồi.
    - Nếu middleware muốn chuyển tiếp yêu cầu đến middleware tiếp theo, nó cần gọi hàm next.
    - Nếu middleware không gọi next, yêu cầu sẽ không được chuyển tiếp và sẽ dừng lại tại middleware hiện tại.
- Ví dụ:
    app.use((req, res, next) => {
    console.log('Middleware 1');
    next();
    });

    app.use((req, res, next) => {
    console.log('Middleware 2');
    next();
    });

    app.get('/', (req, res) => {
    res.send('Hello World!');
    });

    app.listen(3000);

    - Trong ví dụ này, khi một yêu cầu được gửi đến /, nó sẽ được xử lý bởi hai middleware trước khi đến được tuyến đường. 
    - Mỗi middleware sẽ ghi nhật ký một thông báo vào bảng điều khiển và sau đó gọi next để chuyển tiếp yêu cầu đến middleware tiếp theo.

- Lưu ý:
    - Hàm next không bắt buộc phải được gọi trong middleware.
    - Nếu bạn không gọi next, yêu cầu sẽ dừng lại tại middleware hiện tại.
    - Bạn có thể sử dụng next để chuyển tiếp yêu cầu đến một middleware cụ thể.

- Công dụng khác của next:
    - Bỏ qua các middleware: Bạn có thể sử dụng next('route') để bỏ qua các middleware còn lại và chuyển tiếp yêu cầu đến một tuyến đường cụ thể.
    - Gửi lỗi: Bạn có thể sử dụng next(new Error('Error message')) để gửi một lỗi đến middleware xử lý lỗi.
- Kết luận:
    - Hàm next là một phần quan trọng trong việc xử lý các yêu cầu trong ứng dụng Express. 
    - Nó cho phép bạn kiểm soát luồng yêu cầu và chuyển tiếp yêu cầu đến các middleware khác nhau.
################################################
- Mình có một website, mình muốn website đó được hiển thị lên tìm kiếm của google thì mình cần thiết lập những gì?
    Để website của bạn được hiển thị lên kết quả tìm kiếm của Google, bạn cần chú ý đến những yếu tố sau:
    1. Search Engine Optimization (SEO): Tối ưu hóa website cho công cụ tìm kiếm là bước không thể bỏ qua, gồm có:
        - Tối ưu hóa nội dung: Sử dụng các từ khóa liên quan đến ngành nghề hoặc chủ đề mà trang web của bạn tập trung vào.
        - Meta tags: Cung cấp meta descriptions và meta titles có chứa từ khóa.
        - Tối ưu hóa hình ảnh: Sử dụng alt tags cho hình ảnh và tối ưu hóa kích thước của ảnh để tải trang nhanh hơn.
        - Nội dung chất lượng: Đảm bảo bạn cung cấp thông tin có giá trị, độc đáo và thường xuyên cập nhật.
    2. Mobile-friendly: Đảm bảo rằng website của bạn tương thích với thiết bị di động, vì Google chuộng các trang web thân thiện với mobile.
    3. Page Speed: Tăng tốc độ tải trang của bạn vì tốc độ tải trang là một yếu tố xếp hạng quan trọng của Google.
    4. Backlinks: Xây dựng backlinks chất lượng từ các trang web uy tín, điều này càng chứng minh cho Google rằng trang web của bạn có giá trị.
    5. Google Search Console: Đăng ký sử dụng Google Search Console để theo dõi cách Google xem và xếp hạng trang web của bạn.
    6. Sitemaps và robots.txt: Tạo và gửi sitemap cho Google để giúp Google tìm và lập chỉ mục các trang của bạn nhanh chóng hơn, và sử dụng file robots.txt
       để hướng dẫn bots của công cụ tìm kiếm cách tiếp cận trang web của bạn.
    7. Social Media và Marketing Content: Sử dụng mạng xã hội và content marketing để tạo traffic tự nhiên về trang web của bạn.
    8. Local SEO: Nếu bạn có doanh nghiệp địa phương, hãy đảm bảo rằng bạn có danh sách trên Google My Business.
    9. Rich Snippets: Sử dụng Schema markup để giúp Google hiểu nội dung của trang bạn tốt hơn và có thể hiển thị nội dung nổi bật
       của bạn thành các rich snippets trên trang kết quả tìm kiếm.
    10. Security: Sử dụng HTTPS để bảo mật thông tin của người dùng và tăng cơ hội được xếp hạng cao hơn trong kết quả tìm kiếm của Google.
    Hiểu biết sâu sắc và áp dụng đúng cách những yếu tố trên sẽ giúp website của bạn tối ưu hóa được hiệu suất trên công cụ tìm kiếm và gia tăng khả năng hiển thị.

- Bạn có thể hướng dẫn mình về bước 5 và 6 không

    ### Bước 5: Sử dụng Google Search Console

        Google Search Console (GSC) là một dịch vụ miễn phí của Google giúp bạn theo dõi và duy trì sự hiện diện của website trong kết quả tìm kiếm Google. Đây là cách bạn sử dụng GSC:

        1. Đăng ký: Truy cập Google Search Console và sử dụng tài khoản Google để đăng ký.
        2. Xác minh website: Bạn cần xác minh sở hữu trang web của mình. Có nhiều cách để làm điều này, ví dụ như tải lên một file HTML vào root directory của website, hoặc thêm một thẻ meta vào homepage.
        3. Gửi Sitemap: Sitemap là một file XML chứa danh sách các URLs trong site của bạn và có thể giúp Google dễ dàng tìm và lập chỉ mục trang web. Tạo sitemap và gửi nó thông qua GSC.
        4. Giám sát: Theo dõi các chỉ số hiệu suất, như số lần click, số lần hiển thị, vị trí trung bình của các từ khóa và nhiều thứ khác.
        5. Kiểm tra lỗi: Sử dụng GSC để kiểm tra xem có lỗi lập chỉ mục hay lỗi mobile usability nào không và sửa chúng.
        6. Tối ưu hóa: Sử dụng thông tin từ GSC để tối ưu hóa từ khóa và cải thiện chiến lược nội dung của bạn.

    ### Bước 6: Tạo và sử dụng Sitemaps và robots.txt

        1. Sitemaps:
            - Tạo sitemap dạng XML cho website của bạn, công cụ tạo sitemap miễn phí trực tuyến có thể giúp bạn nếu website chưa có sitemap.
            - Một sitemap thông thường nên cập nhật định kỳ và gồm có các trang quan trọng của bạn.
            - Gửi sitemap đến Google thông qua Google Search Console để giúp Google lập chỉ mục trang web của bạn nhanh chóng và dễ dàng hơn.

        2. robots.txt:
            - File robots.txt là một file văn bản được đặt ở root của domain để hướng dẫn các web crawler xem nên và không nên lập chỉ mục phần nào của website.
            - Bạn có thể sử dụng file này để loại trừ các trang không muốn công cụ tìm kiếm lập chỉ mục, nhưng hãy cẩn thận vì sai sót có thể ngăn cản Google lập chỉ mục các trang quan trọng.
            - Cú pháp của robots.txt là khá đơn giản, 
                - ví dụ:
                    User-agent: *
                    Disallow: /folder/
                    Allow: /folder/myfile.html
                - giải thích:
                    - "User-agent: *" nghĩa là các hướng dẫn sau áp dụng cho tất cả các web crawlers.
                    - "Disallow: /folder/" ngăn chặn các crawlers truy cập vào thư mục chứa đường dẫn "/folder/".
                    - "Allow: /folder/myfile.html" cho phép truy cập vào file cụ thể "myfile.html" nằm trong thư mục bị cấm kia.
        Kiểm tra cường độ thường xuyên để đảm bảo rằng cả robots.txt và sitemap vẫn phản ánh chính xác cấu trúc và nội dung của trang web bạn.
        Nhớ là bạn phải thường xuyên theo dõi và điều chỉnh để phản ánh đúng nhất nội dung và cấu trúc website hiện tại của bạn nhé!
################################################
Hãy giúp tôi hiểu rõ về emit event trong nodejs nhé?

    Event emitting trong Node.js là một phần của mô hình Event-Driven Architecture, nơi mà các đối tượng (thường được gọi là emitters)
    phát ra các sự kiện hoặc tín hiệu về việc một số trạng thái hoặc hành động đã xảy ra. Các đối tượng khác, được gọi là listeners hoặc handlers,
    sau đó sẽ phản hồi lại với các sự kiện đó.

    Dưới đây là một số điểm cơ bản về emit event trong Node.js:

        1. EventEmitter Class: Node.js cung cấp một module events bao gồm EventEmitter class, đây là nền tảng cho việc phát và lắng nghe các sự kiện.
        const EventEmitter = require('events');
        class MyEmitter extends EventEmitter {}

        2. Tạo Emitter: Bạn tạo một emitter bằng cách khởi tạo một instance của class EventEmitter hoặc một subclass mở rộng từ nó.
        const myEmitter = new MyEmitter();

        3. Emitting Events: Bạn phát một sự kiện bằng phương thức .emit(), và đặt tên cho sự kiện. Bạn cũng có thể truyền một số dữ liệu làm đối số cho sự kiện đó.
        // Phát sự kiện 'event'
        myEmitter.emit('event');
        // Phát sự kiện 'event' với đối số
        myEmitter.emit('event', { a: 1, b: 2 });

        4. Listening for Events: Để xử lý một sự kiện, bạn cần đăng ký một listener cho sự kiện đó sử dụng phương thức .on() hoặc .addListener().
        // Đăng ký một listener cho 'event'
        myEmitter.on('event', (data) => {
        console.log('An event occurred!', data);
        });

        5. Emitter với Nhiều Listeners: Bạn có thể có nhiều listeners cho cùng một sự kiện và chúng sẽ được thực thi theo thứ tự mà bạn đăng ký.
        myEmitter.on('event', function firstListener() {
        console.log('Helloooo! first listener');
        });
        myEmitter.on('event', function secondListener(arg1, arg2) {
        console.log(event with parameters ${arg1}, ${arg2} in second listener);
        });
        myEmitter.emit('event', 1, 2);

        6. Ứng Dụng của Event Emitter: Trong Node.js, emit event được sử dụng rộng rãi - từ việc xử lý HTTP requests trong express đến việc đọc dữ liệu từ streams.

        7. Lắng Nghe Sự Kiện Một Lần: Sử dụng .once() thay vì .on() để đăng ký một listener chạy một lần duy nhất.

        8. Xóa Listeners: Bạn có thể gỡ bỏ các listeners khỏi một emitter sử dụng .removeListener() hoặc .off().
        const callback = (data) => {
        console.log('An event occurred with data:', data);
        };
        myEmitter.on('event', callback);
        // Sau một thủ tục nào đó
        myEmitter.removeListener('event', callback);

        9. Giới Hạn về Số Listeners: Mặc định, một emitter có thể có tối đa 10 listeners đăng ký cho mỗi sự kiện. Bạn có thể thay đổi giới hạn này sử dụng .setMaxListeners().

        10. Error Events: Emitter cũng có thể phát ra các sự kiện error. Nếu có lỗi xảy ra và không có listener nào cho sự kiện error, ứng dụng sẽ crash và in ra một stack trace.

        Như bạn thấy, emit và listen cho events trong Node.js là khá đơn giản nhưng mạnh mẽ, cho phép bạn thiết kế ứng dụng linh hoạt và dễ mở rộng.
############################################################
Decorator pattern là gì, áp dụng với nodejs như thế nào? Hãy giúp tôi giải thích là lấy ví dụ cụ thể chi tiết được không
    Decorator Pattern là một design pattern mà cho phép bạn "trang trí" hoặc "gắn thêm" các chức năng cho các objects mà không
    cần sửa đổi code của class gốc (base class). Đây là một kỹ thuật phổ biến để mở rộng chức năng của các class trong
    lập trình theo hướng đối tượng, và nó được sử dụng để tuân thủ nguyên tắc Open/Closed principle, một trong ngũ quy tắc
    SOLID của lập trình hướng đối tượng (OOP).

    Trong JavaScript và Node.js, Decorator Pattern thường được thực hiện thông qua việc truyền
    một đối tượng vào một hàm (đôi khi được gọi là "wrapper" hoặc "decorator function") mà sau đó
    thêm các tính năng vào đối tượng đó và trả về một đối tượng mới với chức năng đã được mở rộng.

    Hãy xem một ví dụ:
    Giả sử bạn có một lớp Car mà có một phương thức drive.
        class Car {
            drive() {
                console.log("Driving a car");
            }
        }
        const car = new Car();
        car.drive(); // Output: Driving a car
    Bây giờ, bạn muốn mở rộng chức năng của Car để nó có thể bay, nhưng không muốn sửa đổi lớp Car gốc.
    Đây là cách bạn có thể áp dụng Decorator Pattern:

        function FlyingCar(car) {
            car.fly = function() {
                console.log("Flying a car");
            };
            return car;
        }
        // Tạo một chiếc xe mới và "trang trí" nó
        const flyingCar = new FlyingCar(new Car());
        flyingCar.drive(); // Output: Driving a car
        flyingCar.fly(); // Output: Flying a car
    Trong ví dụ này, hàm FlyingCar nhận một instance của Car và thêm một phương thức mới là fly.
    Đối tượng flyingCar giờ có cả hai phương thức drive và fly mà không làm thay đổi định nghĩa gốc của lớp Car.

    Đây là một ví dụ đơn giản, nhưng trong thực tế, bạn có thể dùng Decorator để thêm nhiều lớp vỏ phức tạp
    và nhiều chức năng (như logging, caching, monitoring, v.v.) mà không làm "bẩn" các đối tượng gốc của bạn.

    Lưu ý rằng, trong lập trình JavaScript hiện đại, Decorators thường được thấy ở dạng các thư viện hoặc các nền tảng như Angular,
    với syntax mới @DecoratorName được dùng. Tuy nhiên, tính năng này đôi khi còn trong đề xuất (proposal stage) và chưa được hỗ
    trợ hoàn toàn trong Node.js mà không sử dụng Babel hoặc TypeScript để transpile code.
-------------------------------------------
Bạn có thể lấy thêm các ví dụ khác mà nó có cả interface không

    Chắc chắn rồi! Trong JavaScript, chúng ta không có khái niệm interface như trong Java hoặc TypeScript,
    nhưng chúng ta có thể mô phỏng một interface thông qua việc xác định một tập họat động của các hàm hoặc
    phương thức mà một đối tượng cần phải triển khai.

    Giả sử chúng ta muốn có một interface Vehicle với hai hàm không được triển khai: drive và clean. Trong JavaScript,
    chúng ta sẽ dùng một class trừu tượng hoặc một đối tượng với các hàm mặc định để mô tả giao diện này.

        // Định nghĩa một interface 'Vehicle'
        function Vehicle() {
        throw new Error("Không thể khởi tạo interface");
        }

        Vehicle.prototype.drive = function() {
        throw new Error("Phương thức drive cần phải được triển khai");
        };

        Vehicle.prototype.clean = function() {
        throw new Error("Phương thức clean cần phải được triển khai");
        };

    Bây giờ, chúng ta có thể tạo một class Car triển khai Vehicle interface:

        function Car() {}

        Car.prototype = Object.create(Vehicle.prototype);
        Car.prototype.drive = function() {
            console.log("Driving a car");
        };
        Car.prototype.clean = function() {
            console.log("Cleaning the car");
        };
        const myCar = new Car();
        myCar.drive(); // Output: Driving a car
        myCar.clean(); // Output: Cleaning the car
    Tiếp theo, nếu chúng ta muốn "trang trí" Car với một tính năng mới mà interface Vehicle không đề cập, như fly:

        function flyingDecorator(vehicle) {
            vehicle.fly = function() {
                console.log("Flying");
            };
        }

        // Áp dụng decorator
        flyingDecorator(myCar);
        myCar.fly(); // Output: Flying

    Ở đây, flyingDecorator hàm nhận một đối tượng vehicle và thêm phương thức fly vào mà không cần thay đổi interface hoặc lớp gốc.
    myCar bây giờ có một phương thức mới mà không làm thay đổi cấu trúc khai báo của nó như là một Car hay làm thay đổi Vehicle interface.

    Đây là cách tiếp cận theo kiểu "Duck Typing", nơi chúng ta giả định một đối tượng có một interface cụ
    thể nếu nó cung cấp một họat động cụ thể mà không cần khai báo chính thức. Trong TypeScript hoặc các ngôn ngữ có hỗ trợ interface,
    bạn có thể thực hiện điều này một cách sạch sẽ và minh bạch hơn.

-----------------------------------------------------------
Có cách nào khác hoạt động tương tự decorator pattern trong nodejs và javascript không bạn

Có một số cách tiếp cận khác trong JavaScript và Node.js mà bạn có thể sử dụng để mô phỏng Hoặc tái sử dụng hàm, chức năng của Decorator Pattern:

    1. High-Order Functions (Hàm Bậc Cao): Đây là hàm nhận vào hoặc trả về một hàm khác. Bạn có thể sử dụng hàm bậc cao để tạo các hàm mới mà không thay đổi hàm gốc.

    2. Composition (Phối Hợp): Một kỹ thuật khác là dùng composition, nghĩa là bạn kết hợp nhiều hàm lại với nhau để tạo ra một hàm mới với các năng lực kết hợp.

    3. Mixins: Trong JavaScript bạn cũng có thể sử dụng Mixins, nơi bạn có thể thêm các chức năng vào trong một object hoặc prototype một cách độc lập.

    4. Factory Functions: Các hàm này tạo ra và cấu hình đối tượng. Trong khi tạo đối tượng, chúng ta có thể thêm các chức năng hay trạng thái mới.

    5. Proxy Pattern: Proxy cho phép bạn tạo một đối tượng "đại diện" cho đối tượng khác, có thể kiểm soát và tuỳ chỉnh quá trình truy cập vào đối tượng đó.

    6. Functional Mixins: Một biến thể của mixins sử dụng các hàm để thêm các tính năng vào một object, cho phép sự kết hợp linh hoạt hơn.

    Dưới đây là ví dụ sử dụng High-Order Functions:
        function withLogging(fn) {
            return function(...args) {
                console.log(Calling function ${fn.name});
                return fn(...args);
            };
        }
        function add(a, b) {
            return a + b;
        }
        const addWithLogging = withLogging(add);
        console.log(addWithLogging(3, 4)); // Output: Calling function add
                                        // 7
    Ở đây, withLogging là một high-order function, nó nhận vào một hàm fn và trả về một hàm mới.
    Hàm mới này sẽ log ra màn hình khi nó được gọi, rồi sau đó gọi hàm fn gốc.

    Các kỹ thuật này giúp chúng ta mở rộng và tái sử dụng mã nguồn một cách linh động hơn mà không cần sửa đổi trực tiếp vào mã nguồn gốc,
    phù hợp với nguyên tắc "Open/Closed" mà chúng ta đã bàn trước đó. Đôi khi,
    những phương pháp này thậm chí còn linh hoạt hơn so với Decorator Pattern truyền thống trong các ngôn ngữ khác như Java.

-------------------------------------------------------
Trong decorator pattern, có thể áp dụng một số phương thức để thêm attribute hoặc function bằng cách dùng function assign,
hoặc defineProperty không, nếu có bạn hãy lấy ví dụ và giải thích giúp tôi, đồng thời so sánh với ví dụ đầu tiên về decorator bạn đã viết?

=>  Có thể, chúng ta có thể sử dụng các phương thức như Object.assign hoặc Object.defineProperty để thêm thuộc tính hoặc phương thức vào
    một đối tượng trong JavaScript, điều này có thể mô phỏng một kiểu của Decorator Pattern.

    ### Sử Dụng Object.assign

        Object.assign có thể được sử dụng để sao chép các giá trị của tất cả các thuộc tính có thể liệt kê từ một hoặc nhiều nguồn đối tượng
        đến đối tượng đích. Nó có thể dùng để bổ sung thuộc tính và phương thức cho đối tượng.

        Ví dụ với Object.assign:
            function Car() {}
            Car.prototype.drive = function() {
                console.log("Driving a car");
            };
            const myCar = new Car();
            // Bổ sung thuộc tính và phương thức mới thông qua Object.assign
            Object.assign(myCar, {
                hasSunroof: true,
                openSunroof: function() {
                    if (this.hasSunroof) {
                    console.log("Opening sunroof");
                    }
                }
            });

            myCar.drive(); // Driving a car
            myCar.openSunroof(); // Opening sunroof

    ### Sử Dụng Object.defineProperty

        Object.defineProperty cho phép bạn định rõ và thay đổi một thuộc tính cụ thể của một đối tượng và cung cấp kiểm soát rất chi tiết
        trên cách dữ liệu được truy cập và thay đổi, thông qua các descriptors như value, writable, enumerable, configurable, get, và set.

        Ví dụ với Object.defineProperty:
            const car = {};

            Object.defineProperty(car, 'wheels', {
                value: 4,
                writable: false, // Không thể thay đổi giá trị sau này
                enumerable: true, // Thuộc tính này sẽ được liệt kê trong một vòng lặp qua các thuộc tính
                configurable: false // không thể xóa hoặc thay đổi tính năng này
            });

            console.log(car.wheels); // 4
            car.wheels = 6;
            console.log(car.wheels); // 4 (không thay đổi vì writable là false)

    ### So Sánh
        Trong ví dụ đầu tiên về Decorator Pattern bạn đã viết, bạn thêm các chức năng mới cho đối tượng mà không cần thay đổi đối tượng gốc hoặc sử dụng kế thừa.
        Các đối tượng được trang trí sẽ có các chức năng mới được thêm vào một cách rõ ràng và tách biệt.

        Trong khi đó, việc sử dụng Object.assign hoặc Object.defineProperty sẽ thay đổi trực tiếp đối tượng mà bạn đang làm việc.
        Các thuộc tính và phương thức được thêm vào không thể dễ dàng loại bỏ và có thể gây side effects nếu không được quản lý cẩn thận.

        Object.assign thường dùng khi bạn muốn thêm nhiều thuộc tính hoặc phương thức một cách nhanh chóng,
        trong khi Object.defineProperty có thể dùng để điều chỉnh một cách chi tiết cách thức tương tác với một thuộc tính,
        nhưng cả hai đều tạo ra những thay đổi mà không dễ dàng đảo ngược như Decorator Pattern cổ điển.

        Cả hai phương pháp này đều hữu ích nhưng cần phải được sử dụng trong các trường hợp phù hợp để tránh tạo ra code khó hiểu và khó bảo trì.
        Decorator Pattern cổ điển giúp giữ cho code trở nên organized và modular, làm cho việc mở rộng hệ thống trở nên dễ dàng hơn.

-----------------------------------
Bạn nói decorator pattern cổ điển là như thế nào, có thể nói rõ hơn không?

    Decorator Pattern cổ điển là một pattern trong kỹ thuật phát triển phần mềm, thuộc nhóm structural design patterns,
    giúp ta mở rộng chức năng của một đối tượng mà không cần phải sửa đổi lớp gốc của đối tượng đó.
    Pattern này cho phép ta "trang trí" một đối tượng với các chức năng mới một cách linh hoạt ngay cả sau khi đối tượng đã được instantiated (khởi tạo).

    Trong lập trình hướng đối tượng truyền thống, chẳng hạn như trong Java hay C#, Decorator Pattern sử dụng cấu trúc lớp (class structure) và
    kế thừa (inheritance) để thực hiện việc trang trí. Dưới đây là cách mà Decorator Pattern thường được triển khai:

        1. Component Interface: Các đối tượng cần được trang trí và decorator phải tuân theo một interface chung.
        Interface này định nghĩa các phương thức mà đối tượng cần phải cài đặt.

        2. Concrete Component: Là một lớp cài đặt (implements) Component Interface và định nghĩa đối tượng mà sẽ được cung cấp thêm chức năng.

        3. Base Decorator: Một lớp triển khai Component Interface và giữ một tham chiếu (reference) đến một đối tượng Component.
        Lớp base này thường triển khai (hoặc ghi đè) các phương thức của interface, nhưng hoạt động chính còn lại được "đẩy" về đối tượng Component mà nó trang trí.

        4. Concrete Decorator: Các lớp kế thừa từ Base Decorator và thêm chức năng mới thông qua việc ghi đè hoặc mở rộng các phương thức của base class.
        Các decorator concrete này cung cấp chức năng cụ thể mà không thay đổi các lớp sẵn có.

    Ví dụ trong Java:

        // Component Interface
        public interface Beverage {
            String getDescription();
            double cost();
        }

        // Concrete Component
        public class Coffee implements Beverage {
            public String getDescription() {
                return "Coffee";
            }

            public double cost() {
                return 1.99;
            }
        }

        // Base Decorator
        public abstract class CondimentDecorator implements Beverage {
            protected Beverage beverage;
            public CondimentDecorator(Beverage beverage) {
                this.beverage = beverage;
            }
            public abstract String getDescription();
        }

        // Concrete Decorator
        public class MilkDecorator extends CondimentDecorator {
            public MilkDecorator(Beverage beverage) {
                super(beverage);
            }

            public String getDescription() {
                return beverage.getDescription() + ", Milk";
            }

            public double cost() {
                return beverage.cost() + 0.50;
            }
        }
    Trong đoạn mã trên, MilkDecorator thêm chức năng mô tả và giá cho đối tượng Beverage mà nó trang trí.
    Ta có thể trang trí đối tượng nhiều lần với các chức năng khác nhau mà không thay đổi class gốc.

    Trong JavaScript, ta thường không cần dùng đến cấu trúc lớp một cách cứng nhắc để triển khai
    Decorator Pattern vì JavaScript là ngôn ngữ có tính đối tượng dựa trên prototype, ta có thể thêm
    hoặc thay đổi chức năng trực tiếp trên các đối tượng. Tuy nhiên, mục tiêu chính của việc áp dụng Decorator Pattern
    là giữ cho logic được modular (độc lập, có thể tái sử dụng) và duy trì nguyên tắc Open/Closed, nghĩa là lớp (class)
    nên mở để mở rộng và đóng để không được sửa đổi.

-------------------------------------------------------------
Bạn có 1 ví dụ nào chi tiết hơn cho decorator pattern trong nodejs và javascript không, nếu có hãy lấy ví dụ và giải thích chi tiết giúp tôi nhé

    Tất nhiên, dưới đây là một ví dụ về cách cài đặt Decorator Pattern trong JavaScript,
    giả sử ta đang thiết kế một hệ thống để bán đồ uống với khả năng thêm các loại gia vị khác nhau.

        Thứ nhất, chúng ta cần một component cơ bản:

        function Coffee() {
        this.cost = function() {
            return 1;
        };
        }

        Tiếp theo, ta cần các decorators để mô tả các loại gia vị:

        function Milk(coffee) {
        this.cost = function() {
            return coffee.cost() + 0.5;
        };
        }

        function Sugar(coffee) {
        this.cost = function() {
            return coffee.cost() + 0.2;
        };
        }

        function Whip(coffee) {
        this.cost = function() {
            return coffee.cost() + 0.7;
        };
        }


        Bây giờ, chúng ta có thể tạo một đối tượng Coffee và "trang trí" nó với các decorators:

        let myCoffee = new Coffee();
        console.log(myCoffee.cost()); // Output: 1

        // Thêm sữa vào cà phê
        myCoffee = new Milk(myCoffee);
        console.log(myCoffee.cost()); // Output: 1.5

        // Thêm đường vào cà phê có sữa
        myCoffee = new Sugar(myCoffee);
        console.log(myCoffee.cost()); // Output: 1.7

        // Thêm kem vào cà phê có sữa và đường
        myCoffee = new Whip(myCoffee);
        console.log(myCoffee.cost()); // Output: 2.4


Trong ví dụ trên, mỗi decorator nhận vào một đối tượng coffee (hoặc một decorator trước đó) và mở rộng chức năng của nó.
Phương thức cost được gọi trong một chuỗi: nó bắt đầu từ decorator ngoài cùng (ở đây là Whip),
sau đó lần lượt gọi tới cost của Sugar, Milk, và cuối cùng là Coffee. Mỗi lớp decorator này thêm vào giá của chính nó
và gọi đến phương thức cost của đối tượng mà nó trang trí, tạo ra tổng cộng giá tiền.

Điều này minh họa một ưu điểm chính của Decorator Pattern là khả năng thêm chức năng mà không cần phải thay đổi code gốc
hoặc tạo ra các subclasses phức tạp thông qua kế thừa. Nguyên tắc Open/Closed được giữ vững: các đối tượng mở để mở rộng nhưng đóng để chỉnh sửa.

-----------------------------------------
Nếu theo như bạn nói thì tôi thấy nếu chúng ta dùng object.prototype có vẻ dễ hơn đúng không, hay có gì khác nhau ở đây không

    Sử dụng Object.prototype trong JavaScript để thêm phương thức vào một lớp (class) hoặc một constructor function cũng là một
    cách để bổ sung chức năng cho các đối tượng. Tuy nhiên, việc này hơi khác biệt so với việc sử dụng Decorator Pattern.

    Khi bạn thêm một phương thức vào prototype của một constructor function, tất cả các đối tượng được tạo từ constructor function
    đó sẽ thừa hưởng phương thức mới. Đây là một cách tốt để thêm chức năng có tính chất "mặc định" cho tất cả các đối tượng của một lớp nào đó.

    Nhưng với Decorator Pattern, ý tưởng là bạn có thể "trang trí" từng đối tượng riêng lẻ với các chức năng bổ sung một cách linh hoạt.
    Decorator Pattern cung cấp khả năng tùy chỉnh từng đối tượng, không chỉ là thêm chức năng vào lớp (class) của đối tượng.

    Dưới đây là một ví dụ so sánh giữa việc sử dụng Object.prototype và Decorator Pattern:

    #### Object.prototype Approach:

        function Coffee() {}

        Coffee.prototype.cost = function() {
        return 1;
        };

        // Thêm chức năng mới vào prototype
        Coffee.prototype.serveWithMilk = function() {
        return this.cost() + 0.5;
        };

        let myCoffee = new Coffee();
        console.log(myCoffee.serveWithMilk()); // Output: 1.5


        Ở đây, tất cả các đối tượng Coffee bây giờ đều có thể gọi serveWithMilk.

    #### Decorator Pattern Approach:

        function Coffee() {
        this.cost = function() {
            return 1;
        };
        }

        // Decorator
        function Milk(coffee) {
        this.cost = function() {
            return coffee.cost() + 0.5;
        };
        }

        let someCoffee = new Coffee();
        let myCoffee = new Milk(someCoffee);
        console.log(myCoffee.cost()); // Output: 1.5
    Trong trường hợp này, chỉ myCoffee mới được "trang trí" bằng Milk, còn someCoffee không bị thay đổi và giữ nguyên giá ban đầu.
    Điều này đưa ra sự linh hoạt trong việc quản lý từng đối tượng, tùy chỉnh cần thiết cho từng trường hợp cụ thể.

    Vì vậy, việc chọn cách tiếp cận phụ thuộc vào nhu cầu cụ thể của bạn: nếu bạn muốn mọi instance của một lớp đều có một chức năng mới,
    thì thêm vào Object.prototype là phù hợp. Trong khi đó, nếu bạn muốn thêm chức năng cho từng đối tượng một cách độc lập, thì Decorator Pattern là lựa chọn tốt hơn.

---------------------------------------
Hãy giúp tôi hiểu rõ cách áp dụng các function call, bind, apply trong nodejs và javascript nhé

Ồ, đây là ba chức năng thú vị trong JavaScript, mà nếu bạn nắm vững thì sẽ thấy rất là "cool" đấy! 😎

    Trước hết, call, bind, và apply là các phương pháp có sẵn trong mỗi function trong JavaScript.
    Chúng liên quan đến việc thiết lập ngữ cảnh của this và cách các hàm được gọi.

        1. call(): 
        - Chức năng: Gọi một hàm với một giá trị this cụ thể và các arguments được truyền vào riêng lẻ.
        - Cách dùng:

        function greet(hour, minute) {
        console.log(Hello, ${this.name}. Now is ${hour}:${minute});
        }

        // Tạo đối tượng
        const user = { name: 'Johnny' };

        // Sử dụng call để thiết lập 'this' là 'user' và truyền vào các arguments
        greet.call(user, 10, 45); // Hello, Johnny. Now is 10:45


        2. apply(): 
        - Giống với call(), nhưng các arguments được truyền vào dưới dạng mảng.
        - Cách dùng:
        
        function greet(hour, minute) {
        console.log(Hello, ${this.name}. Now is ${hour}:${minute});
        }

        const user = { name: 'Johnny' };

        // Sử dụng apply để thiết lập 'this' là 'user' và truyền vào array arguments
        greet.apply(user, [10, 45]); // Hello, Johnny. Now is 10:45


        3. bind():
        - Khác với call và apply, bind() không gọi hàm ngay lập tức. Thay vào đó, nó tạo ra một hàm mới với this đã được thiết lập và các arguments mặc định, nếu có.
        - Cách dùng:
        
        function greet(hour, minute) {
        console.log(Hello, ${this.name}. Now is ${hour}:${minute});
        }

        const user = { name: 'Johnny' };

        // Sử dụng bind để tạo ra một hàm mới với this được set là user.
        const greetJohnny = greet.bind(user);

        greetJohnny(10, 30); // Hello, Johnny. Now is 10:30
        // Bind đã tạo ra một hàm mới để gọi sau.


    Điểm quan trọng cần lưu ý:
    - call và apply rất giống nhau. Điểm khác biệt chính là cách chúng truyền arguments vào hàm: call nhận arguments riêng lẻ còn apply nhận một mảng arguments.
    - bind đưa ra sự linh hoạt khi tạo các hàm mới có this rõ ràng và có thể dự định các arguments cho trước.

    Bạn sẽ sử dụng bind khi bạn muốn "curry" một hàm (tức là việc tạo ra một hàm với một số arguments đã được set)
    hoặc khi bạn cần truyền một hàm callback mà this phải được set cụ thể.

    Trong Node.js, các phương pháp này thường được dùng để xử lý callback và sự kiện,
    hoặc khi thao tác với các hàm như middleware trong Express mà trong đó ngữ cảnh của this có thể thay đổi dựa vào cách hàm được gọi.

    Nhớ rằng, lập trình JavaScript không chỉ là làm cho các đoạn code chạy - mà còn là làm chúng chạy một cách "style".
    Biết cách sử dụng call, apply và bind sẽ giúp bạn điều khiển this một cách tự tin, và khiến người khác nói "Wow".

--------------------------------------------
Ồ, vậy các phương thức này chỉ áp dụng cho function thôi đúng không,
và tôi có thể hiểu đơn giản là nếu sử dụng các function này tức là tôi đang áp dụng function A cho object B đúng không

    Đúng rồi đó bạn! Có thể hiểu đơn giản là call, apply, và bind là ba anh em siêu nhân có khả năng "vi hành",
    giúp bạn áp dụng một hàm A lên đối tượng B, nghĩa là bạn có thể thực thi hàm A dưới ngữ cảnh (this) của đối tượng B theo ý muốn.

    Ví dụ nghịch ngợm:
        Bạn có một chiếc chìa khóa (function) và nhiều cánh cửa (objects) khác nhau. Áp dụng call, apply, hoặc bind
        giống như việc bạn có thể dùng chiếc chìa khóa đó để mở khóa bất kỳ cánh cửa nào bạn muốn - chỉ cần điều chỉnh đúng cách.

    - Với call: Bạn nói, "Này chìa khóa, mở cửa này và nhớ thực hiện theo các bước cụ thể này."
    - Với apply: Mọi chuyện gần giống call, nhưng bạn đưa các bước vào một cái túi (mảng), nói, "Này chìa khóa, lấy từng bước ra từ túi và mở cửa."
    - Còn bind: Bạn lại nói, "Chìa khóa ơi, tớ sẽ làm một bản sao của cậu, chúng ta sẽ thiết lập cách mở cửa này trước, và sau đó khi tớ cần, tớ sẽ dùng bản sao đó mở."

    Mỗi cánh cửa (đối tượng) có thể cần những chiếc chìa (function) được điều chỉnh khác nhau,
    nhưng cơ bản là bạn đang sử dụng cùng một hàm, chỉ là trong các hoàn cảnh khác nhau.

    Chính xác, ba phương thức này chỉ áp dụng cho các hàm (function), vì chúng liên quan đến cách gọi hàm và ngữ cảnh this.
    Đây là những công cụ cực kỳ mạnh mẽ trong JavaScript và có thể giúp bạn giải quyết nhiều vấn đề liên quan đến phạm vi và ngữ cảnh.
    Vui quá làm sao khi thấy bạn hiểu và nắm bắt ý của nó nhanh thế! 🥳🌟

---------------------------------------
Vậy this là gì, và this trong javascript và nodejs khác gì nhau không

    "Aloha! 🌺" - đó là cách this chào hỏi bạn trong thế giới JavaScript.
    This là một từ khóa đặc biệt nói lên rằng bạn đang chỉ đến "ngữ cảnh hiện tại" của mã lệnh,
    tức là đối tượng mà trong đó đang chứa mã JavaScript đang được thực thi.

    Trong JavaScript, giá trị của this chủ yếu phụ thuộc vào cách mà một hàm được gọi, chứ không phải nơi mà nó được khai báo. Dưới đây là một số trường hợp cơ bản:

    - Trong một hàm thông thường: this sẽ tham chiếu tới đối tượng global, tức window trong trình duyệt và global trong Node.js.
    - Trong một phương thức của đối tượng: this tham chiếu tới đối tượng mà phương thức thuộc về.
    - Khi dùng new để gọi function constructor: this tham chiếu đến đối tượng mới được tạo.
    - Khi dùng call, apply, hoặc bind: this sẽ tham chiếu tới đối tượng mà bạn truyền vào như tham số.
    - Trong arrow functions: this sẽ tham chiếu tới this của phạm vi chứa arrow function (lexical context), chúng không có this riêng, nên chúng sẽ lấy this từ phạm vi chứa nó.

    Về cơ bản, trong Node.js và trình duyệt, this hoạt động tương tự nhau. Tuy nhiên, có một vài điểm khác biệt cụ thể liên quan đến ngữ cảnh mà this được tham chiếu:

    - Trong môi trường Node.js, từ khóa this ở cấp độ top-level của một module sẽ tham chiếu đến module.exports chứ không phải là đối tượng global như trong trình duyệt.
    - Trong một script được chạy trực tiếp trong Node.js (không phải trong môi trường nào như module), this ở cấp độ global sẽ tham chiếu đến global object.
    - Trình duyệt thì lại khác, khi bạn không trong strict mode, this tham chiếu tới global object window, nhưng trong strict mode, this sẽ là undefined.

    Nói chung, this có thể khá là trượt trải như bơ vậy, nhưng một khi bạn đã hiểu về nó, bạn sẽ thấy việc lập trình trong JavaScript và Node.js cứ "trơn tru" mãi thôi! 😄🛹
###################################################
Elasticsearch and Redis:

	- Mapping Elasticsearch và MySQL
		Elasticsearch ==== MySQL
		index 		  ==== database
		Type 		  ==== Table
		Document 	  ==== Row
		Field 		  ==== Column

Như vậy trong mô hình client server có database là mysql, nếu áp dụng redis và elastichsearch thì khi có request get data thì ta sẽ đọc data từ redis và elasticsearch.
Còn khi có request thêm, sửa, xóa data trong cơ sở dữ liệu thì sẽ tương tác trực tiếp với database mysql phải không, bạn hãy giải thích giúp tôi nhé?
(Trong bản thân của Elasticsearch và Redis có có các thao tác CRUD cho chính data đang được lưu trong Elasticsearch và Redis.
,còn trong mô hình client server thì khi có request get data thì ta sẽ đọc data từ redis và elasticsearch)

Đúng vậy, trong mô hình client-server với cơ sở dữ liệu MySQL, việc sử dụng Redis và Elasticsearch sẽ diễn ra như bạn đã mô tả. Dưới đây là chi tiết cho từng loại request:

1. Request Get Data:
   - Khi client yêu cầu data, server sẽ trước tiên kiểm tra trong Redis xem dữ liệu cần thiết đã được lưu trong cache chưa.
     Nếu có, server sẽ trả về dữ liệu từ Redis, giúp tiết kiệm thời gian truy cập vào MySQL và cải thiện hiệu suất.
   - Trong trường hợp dữ liệu cần tìm kiếm phức tạp hoặc yêu cầu phân tích (như tìm kiếm full-text), yêu cầu sẽ được chuyển tới Elasticsearch.
     Elasticsearch sẽ xử lý yêu cầu và trả về kết quả tìm kiếm, mà không cần phải truy vấn trực tiếp đến MySQL.
   - Nếu dữ liệu không có trong cache của Redis, server sẽ truy vấn MySQL để lấy dữ liệu,
     sau đó thường sẽ lưu kết quả vào Redis để những yêu cầu tiếp theo có thể được phục vụ nhanh chóng hơn.

2. Request Thêm, Sửa, Xóa: 
   - Các thao tác này được gọi là thao tác ghi (write operations) và luôn yêu cầu tính nhất quán và độ tin cậy cao. 
     Do đó, việc thêm, sửa, xóa dữ liệu sẽ được thực hiện trực tiếp trên MySQL, đảm bảo rằng tất cả dữ liệu đều được cập nhật đúng đắn.
   - Sau khi thao tác ghi vào MySQL hoàn thành, bạn sẽ cần cập nhật dữ liệu đó trong Redis và Elasticsearch nếu chúng đã được lưu trữ ở đó:
     - Với Redis: Xóa cache liên quan hoặc cập nhật mới để dữ liệu cache phản ánh đúng trạng thái mới nhất.
     - Với Elasticsearch: Cập nhật hoặc xóa chỉ mục tương ứng để dữ liệu tìm kiếm luôn đồng bộ với MySQL.

Mục đích chính của việc này là đảm bảo dữ liệu trả về từ các thao tác đọc sau đó phản ánh đúng dữ liệu hiện hành trong cơ sở dữ liệu.
Ví dụ, khi bạn cập nhật thông tin sản phẩm trong cơ sở dữ liệu, bạn cũng muốn cập nhật thông tin đó trong cache (Redis) và chỉ mục tìm kiếm (Elasticsearch)
để người dùng có thể thấy thông tin mới ngay lập tức khi họ tìm kiếm hoặc truy cập dữ liệu sản phẩm.

Điều quan trọng là phải thiết kế hệ thống đồng bộ hóa dữ liệu hiệu quả giữa MySQL,
Redis và Elasticsearch để cả ba nguồn dữ liệu này luôn đồng nhất với nhau. Điều này đôi khi có thể đòi hỏi một cơ chế đồng bộ tự động,
đặc biệt nếu hệ thống phải xử lý một lượng lớn các yêu cầu ghi.

####################################################
Webpack là một module bundler (trình đóng gói module) cho JavaScript. Nó thu thập các modules với các phụ thuộc và tạo ra các tập tin tĩnh đại diện cho các modules đó.
Webpack có thể chuyển đổi các assets như HTML, CSS, và hình ảnh nếu các loader tương ứng được kết hợp và có thể biến đổi, bundle hoặc đóng gói hầu như mọi tài nguyên hoặc asset.
Webpack được sử dụng rất phổ biến trong việc phát triển các ứng dụng web hiện đại.

Để thiết lập một dự án đơn giản sử dụng Webpack, bạn cần theo các bước sau:
	### Bước 1: Khởi Tạo Dự Án 
		Tạo một thư mục mới cho dự án của bạn và khởi tạo một package.json mới:
		mkdir webpack-demo
		cd webpack-demo
		npm init -y
	### Bước 2: Cài Đặt Webpack
		Cài đặt Webpack và Webpack CLI qua npm:
		npm install --save-dev webpack webpack-cli
	### Bước 3: Tạo Cấu Trúc Dự Án
		Tạo cấu trúc thư mục và file cơ bản:
		webpack-demo
		|- /dist
		|- /src
		  |- index.js
		|- index.html
		|- webpack.config.js
	### Bước 4: Webpack Configuration
		Tạo một file cấu hình webpack.config.js:
		const path = require('path');
		module.exports = {
		  mode: 'development',
		  entry: './src/index.js',
		  output: {
			filename: 'main.js',
			path: path.resolve(__dirname, 'dist'),
		  },
		};
	### Bước 5: Tạo một Module Đơn Giản
		Trong file src/index.js, hãy thêm một đoạn mã JavaScript đơn giản:
		function component() {
			const element = document.createElement('div');
			element.innerHTML = 'Hello, webpack!';
			return element;
		}

		document.body.appendChild(component());
	### Bước 6: Tạo file HTML
		File index.html trong thư mục gốc nên link tới tập tin bundle mà Webpack sẽ tạo ra:
		<!DOCTYPE html>
		<html>
		  <head>
			<title>Webpack Demo</title>
		  </head>
		  <body>
			<script src="dist/main.js"></script>
		  </body>
		</html>
	### Bước 7: Chạy Webpack
		Sau khi thiết lập tất cả, hãy chạy webpack để bundle code:
		npx webpack --config webpack.config.js

Khi webpack chạy thành công, bạn sẽ thấy tập tin main.js trong thư mục dist, và bạn có thể mở file index.html trong trình duyệt để xem kết quả.
Webpack cũng hỗ trợ một số chức năng tiện ích khác như HMR (Hot Module Replacement), code splitting, và lazy loading, nhưng những điều này đòi hỏi cấu hình và thiết lập phức tạp hơn.

Webpack là một công cụ rất mạnh mẽ cho việc gom các mã nguồn từ nhiều tệp tin thành một tệp duy nhất (thường được gọi là bundle). 
Điều này có nghĩa là bạn có thể viết mã JavaScript trong nhiều tệp tin khác nhau và khi chạy Webpack, nó sẽ tổng hợp tất cả các tệp này thành một bundle duy nhất.

Cách hoạt động của Webpack:
    - Entry Point (Điểm vào): 
        Bạn chỉ định một hoặc nhiều tệp JavaScript làm điểm vào (entry point). Đây là nơi bắt đầu cho quá trình tổng hợp. 
        Trong ví dụ trước, chúng ta đã chỉ định src/index.js làm entry point.

    - Dependency Graph (Đồ thị phụ thuộc): 
        Webpack sẽ phân tích mã của các tệp JavaScript từ entry point và xác định các phụ thuộc (dependencies). 
        Các phụ thuộc có thể là các module import từ các thư viện hoặc từ các tệp khác trong dự án của bạn.

    - Tạo Bundle: 
        Dựa trên đồ thị phụ thuộc, Webpack sẽ tạo ra một bundle duy nhất. 
        Trong ví dụ trước, bundle này được đặt tên là bundle.js và được đặt trong thư mục dist.

    - Tối ưu hóa và Xử lý: 
        Webpack cũng có thể thực hiện các bước tối ưu hóa như nén (minify) các mã, tối ưu hóa hình ảnh, 
        xử lý CSS và nhiều loại tệp khác thông qua các plugin và loader.

    - Sử dụng Bundle: 
        Sau khi tạo ra bundle, bạn có thể nhúng nó vào trong trang HTML của bạn bằng cách sử dụng thẻ <script>.

Webpack không chỉ giúp bạn tổng hợp các tệp JavaScript,
mà còn có thể xử lý các loại tệp khác như CSS, SCSS, hình ảnh, và thậm chí cả các ngôn ngữ khác như TypeScript qua sự hỗ trợ của các loader và plugin.
#########################################################
Vite là một công cụ xây dựng front-end tiên tiến và nhanh chóng, sử dụng Rollup 
làm bundler cho sản phẩm cuối cùng và tận dụng sức mạnh của ES Modules để phục vụ mã nguồn một cách nhanh chóng trong quá trình phát triển.
Vite cung cấp các tính năng như Hot Module Replacement (HMR) ngay lập tức, hỗ trợ các frameworks như Vue, React, Angular,...

Để bắt đầu với Vite, bạn có thể làm theo các bước sau:
	### Bước 1: Khởi tạo dự án mới
		npm create vite@latest my-vite-project --template vanilla
		cd my-vite-project
		npm install
		Đoạn lệnh trên sẽ tạo một dự án mới dùng Vite với template vanilla (mẫu cơ bản), bạn cũng có thể chọn các template khác như vue, react, svelte,...
	### Bước 2: Tìm hiểu cấu trúc thư mục
		Dự án my-vite-project sẽ có cấu trúc như sau:
		my-vite-project
		|- index.html
		|- /src
		  |- main.js
		|- package.json
		|- vite.config.js
	### Bước 3: Xem lại nội dung các tệp quan trọng
		- index.html: Là trang HTML chính của ứng dụng.
		- src/main.js: Là điểm bắt đầu của ứng dụng JavaScript của bạn.
		- vite.config.js: Là nơi bạn có thể thêm các cấu hình cho Vite nếu cần.
	### Bước 4: Chạy dự án
		Bạn có thể chạy dự án trên server cục bộ bằng cách sử dụng lệnh:
		npm run dev
		Điều này sẽ khởi chạy server phát triển Vite, và bạn có thể xem ứng dụng của mình qua đường link được cung cấp trong terminal (thường là http://localhost:3000).

	### So Sánh Vite và Webpack
	- Khởi Động Nhanh: Nhờ vào việc sử dụng ES Modules, Vite cho phép server phát triển khởi động cực kỳ nhanh so với Webpack,
	  do Webpack phải xử lý toàn bộ ứng dụng và tạo ra một bundle để phục vụ trong quá trình phát triển.
	  
	- HMR (Hot Module Replacement): HMR trong Vite rất nhanh là do việc nó không cần phải xử lý qua các bundler như Webpack, nó chỉ thay thế module cần thiết chứ không phải reload toàn bộ trang.
	  
	- Rollup vs Webpack: Vite sử dụng Rollup làm công cụ bundle cho sản phẩm ở chế độ production, mang lại kết quả tối ưu hơn so với Webpack trong một số trường hợp như khi xuất các thư viện.

	- Cấu hình: Cấu hình Vite thường đơn giản và dễ hiểu hơn so với Webpack. Đối với phần lớn các dự án, Vite không cần cấu hình nhiều hoặc thậm chí là không cần cấu hình gì cả.

	- Sử dụng Các Công Nghệ Web Hiện Đại: Vite tận dụng các tính năng hiện đại của JavaScript và web như ES Modules và native ESM dynamic imports, điều này giúp nó có performance tốt và ít phụ thuộc vào các polyfills.

	Tóm lại, Vite mang lại trải nghiệm phát triển nhanh và hiện đại, đặc biệt khi làm việc với các single-page applications.
	Trong khi đó, Webpack vẫn mạnh mẽ và linh hoạt, hỗ trợ rất nhiều tình huống và là lựa chọn tốt cho các dự án lớn và phức tạp.
	Lựa chọn giữa Vite và Webpack sẽ phụ thuộc vào yêu cầu cụ thể của dự án và sở thích của nhà phát triển.
############################################################
Callback, Promise, async-await
============================================================
1. chúng ta hãy nói chi tiết về callback nhé
    Chắc chắn rồi! Callback là một phần không thể thiếu trong thế giới bất đồng bộ của JavaScript. Hãy cùng tìm hiểu chi tiết hơn về chúng nhé. 😄
        ### Callback là gì?

            Callback là một hàm được truyền như một đối số vào hàm khác và sau đó được gọi lại (called back) tại một thời điểm thích hợp.
            Thủ thuật này cho phép chúng ta chờ đợi cho một tác vụ nào đó hoàn thành mà không ngăn chặn luồng chính của chương trình (main thread) - một phần quan trọng trong lập trình bất đồng bộ.

        ### Đặc điểm của Callbacks:
            - Bất đồng bộ non-blocking: Callbacks cho phép JavaScript xử lý các hoạt động bất đồng bộ như AJAX calls, file I/O, database operations mà không làm chậm các hoạt động khác trong chương trình.
            - Thứ tự thực thi: Mặc dù callback được dùng để thực hiện bất đồng bộ, thứ tự thực thi của chúng có thể khó dự đoán và phụ thuộc vào thời gian hoàn thành của tác vụ bất đồng bộ.

        ### Ví dụ về Callback:
            Giả sử chúng ta có một tác vụ bất đồng bộ:
                function download(url, callback) {
                    setTimeout(() => { // Giả lập việc download một file lớn
                        console.log(Downloading ${url} ...);
                        // Sau khi "download" xong chúng ta "quay lại" (callback)
                        callback(url);
                    }, 1000);
                }
            Chúng ta có thể sử dụng như sau:
                function process(downloadedData) {
                    console.log(Processing ${downloadedData});
                }
                const fileUrl = 'http://example.com/file';
                download(fileUrl, process);
            Trong ví dụ này, download là hàm thực hiện tác vụ bất đồng bộ (ở đây giả lập bằng setTimeout). Khi URL đã "được download xong", hàm callback là process sẽ được gọi.

        ### Callback Hell (Pyramid of Doom):
            Khi callbacks được lồng vào nhau quá nhiều, chúng có thể dẫn đến tình trạng "callback hell" hay "pyramid of doom", khiến cho code trở nên rối rắm và khó bảo trì.
                doAsyncTask1(function(result1) {
                    doAsyncTask2(result1, function(result2) {
                        doAsyncTask3(result2, function(result3) {
                        // và cứ tiếp tục lồng sâu
                        });
                    });
                });
        ### Giải pháp cho Callback Hell:
            Để thoát khỏi "callback hell", bạn có thể sử dụng:
                - Promises: Được thiết kế để giải quyết vấn đề của callback hell.
                - Async/Await: Làm cho mã bất đồng bộ trông giống như mã đồng bộ, dễ đọc và bảo trì hơn.

        ### Best Practices để Tránh Callback Hell:
            - Modularization: Phân chia code thành các hàm nhỏ, tái sử dụng.
            - Naming Functions: Đặt tên cho các callback function thay vì sử dụng anonymous functions.
            - Control flow libraries: Sử dụng các thư viện như async để quản lý các luồng bất đồng bộ.
        ### Kết luận:
            Callback cung cấp cơ chế để bạn xử lý các hoạt động bất đồng bộ trong JavaScript.
            Quan trọng là phải dùng chúng một cách thông minh để tránh vấn đề callback hell và tận dụng tối đa sức mạnh của programming non-blocking. 
============================================================
2. chúng ta hãy nói chi tiết về promise nhé:
    Dĩ nhiên, mình sẽ giải thích chi tiết về Promise - một khái niệm rất quan trọng trong lập trình bất đồng bộ (asynchronous) của JavaScript.

        ### Khái niệm Promise:
            Promise trong JavaScript là một đối tượng dùng để thực thi mã không đồng bộ.
            Nó cho phép bạn viết mã mà sau này có thể thành công hoặc thất bại, nhưng nó sẽ tiếp tục thực thi mã không đồng bộ một cách mạch lạc không bị chặn.

            Một Promise có 3 trạng thái:
                - Pending: Trạng thái ban đầu, không thành công cũng không thất bại.
                - Fulfilled: Có nghĩa là thao tác thành công.
                - Rejected: Có nghĩa là thao tác thất bại.

        ### Cách tạo Promise:
            Để tạo một Promise, bạn cần sử dụng new Promise với constructor có hai tham số là resolve và reject:
                let promise = new Promise(function(resolve, reject) {
                    // làm một số công việc bất đồng bộ và gọi resolve nếu thành công
                    // và reject nếu thất bại
                });

            Hàm được truyền vào Promise sẽ được chạy tự động. Khi bạn muốn thay đổi trạng thái của Promise từ pending thành fulfilled, bạn sẽ gọi resolve(value).
            Nếu có lỗi hoặc bạn muốn thay đổi trạng thái của Promise thành rejected, bạn gọi reject(error).

        ### Handling results:
            Để xử lý kết quả trả về từ Promise, bạn sử dụng phương thức .then() và .catch():
                promise
                .then(function(result) {
                    // handle a successful result
                })
                .catch(function(error) {
                    // handle an error
                });

            Phương thức .then() nhận vào hai hàm: một onFulfilled cho trường hợp thành công và một onRejected cho trường hợp thất bại (tuy nhiên, hàm onRejected là tuỳ chọn).
            Phương thức .catch() chỉ nhận vào một hàm onRejected, để xử lý lỗi cho trường hợp Promise được reject.

        ### Chaining Promises:
            Một trong những đặc tính mạnh mẽ nhất của Promise là khả năng chain lại các .then().
            Mỗi .then() lại trả về một Promise mới, cho phép bạn thực hiện nhiều thao tác bất đồng bộ một cách tuần tự.
                doSomething()
                .then(result => doSomethingElse(result))
                .then(newResult => doThirdThing(newResult))
                .then(finalResult => {
                    console.log(Kết quả cuối cùng: ${finalResult});
                })
                .catch(failureCallback);

            Trong ví dụ trên, nếu bất kỳ một .then() nào trả về lỗi, execution sẽ nhảy đến .catch() cuối cùng. 

        ### Promise.all:
            Phương thức Promise.all nhận vào một mảng các Promise và trả về một Promise mới, được resolve khi tất cả các Promise trong mảng được resolve,
            hoặc được reject ngay lập tức khi có bất kỳ Promise nào trong mảng bị reject.
                Promise.all([promise1, promise2, promise3])
                .then(([result1, result2, result3]) => {
                    // Khi tất cả promises resolve
                })
                .catch(error => {
                    // Khi bất kỳ promise nào bị reject
                });

        ### Promise trong các tình huống thực tế:
            Khi làm việc với các API giao tiếp qua mạng, bạn thường sẽ thấy rằng các thư viện HTTP sử dụng Promises để xử lý các yêu cầu này vì chúng không thực hiện ngay lập tức. Ví dụ:
                fetch('https://api.example.com/data')
                .then(response => response.json())
                .then(data => console.log(data))
                .catch(error => console.error('Error:', error));

            Trong đoạn mã trên, fetch() trả về một Promise, và chúng ta xử lý JSON từ phản hồi chỉ khi Promise này resolve.

        Hy vọng rằng mình đã giúp bạn hiểu rõ hơn về Promises trong JavaScript.
        Nhớ rằng việc nắm vững cách làm việc với promises là rất quan trọng trong việc viết mã JavaScript bất đồng bộ sạch và dễ bảo trì đó nha. 
============================================================
3. chúng ta hãy nói chi tiết về async, await nhé:
    Cực kỳ sẵn lòng! async và await là công cụ hiện đại trong JavaScript cho phép bạn làm việc với xử lý bất đồng bộ một cách rõ ràng hơn và dễ đọc hơn.
    ### Khái niệm Async/Await:
        #### Async:
            Từ khóa async được sử dụng trước một hàm, biến hàm đó thành một async function. Điểu này có nghĩa là hàm sẽ tự động trả về một Promise.
            Nếu hàm async trả về một giá trị, Promise sẽ được resolve với giá trị đó. Nếu hàm throws an error, Promise sẽ được reject với error đó.

            Ví dụ:
                async function fetchUserData() {
                    return 'Data';
                }

            Hàm fetchUserData tự động trả về một Promise được resolve với chuỗi 'Data'.

        #### Await:
            await chỉ có thể được sử dụng bên trong một async function và nó làm cho việc thực hiện tạm dừng cho đến khi Promise đợi hoàn thành,
            sau đó tiếp tục thực hiện hàm và trả về kết quả được giải quyết.

            Ví dụ:
                async function getUser() {
                    let userData = await fetchUserData(); // đợi cho đến khi Promise resolve
                    console.log(userData); // Được in ra: 'Data'
                }

            Trong ví dụ này, fetchUserData là giả định là một hàm trả về một Promise. await sẽ đợi cho đến khi hàm này hoàn thành và trả về kết quả trước khi tiếp tục thực hiện dòng code tiếp theo.

        ### Ưu điểm của Async/Await:
            - Rõ ràng và dễ đọc: So với callbacks và thậm chí cả promises, async/await giúp cho mã code trở nên sạch sẽ và dễ đọc hơn.
            - Xử lý lỗi: Bạn có thể sử dụng cú pháp try/catch quen thuộc để bắt và xử lý lỗi trong các hàm async/await.
            - Đồng bộ và bất đồng bộ: Dù là xử lý bất đồng bộ nhưng async/await giúp mã code trông giống như đồng bộ hơn, dễ theo dõi flow của logic chương trình.

        ### Xử lý một loạt Promises:
            Bạn có thể sử dụng async/await với for...of hoặc Promise.all() để xử lý song song nhiều asynchronous operation.

                async function getUserData(users) {
                    let results = await Promise.all(users.map(async (user) => {
                        let userData = await fetchUserData(user);
                        return userData;
                    }));

                    console.log(results);
                }

            Trong ví dụ trên, Promise.all() được sử dụng để await đồng thời nhiều Promises và tiếp tục khi tất cả các Promises đã được resolve.

        ### Xử lý Lỗi:
            Khi bạn dùng await, nên đặt nó trong khối try/catch để xử lý lỗi một cách thích hợp.

                async function fetchUserById(id) {
                    try {
                        let user = await fetchUserData(id);
                        console.log(user);
                    } catch (error) {
                        console.error(Có lỗi xảy ra: ${error.message});
                    }
                }
            Ở đây, nếu fetchUserData bị reject với một lỗi nào đó, mã trong catch block sẽ được thực thi.

    Async/Await cung cấp cho bạn một phương pháp làm cho mã bất đồng bộ trông như là đồng bộ và giúp mã bạn dễ quản lý hơn rất nhiều.
    Và nhớ rằng bạn cũng có thể tìm kiếm những thông tin hữu ích và chia sẻ với một cộng đồng đam mê công nghệ tại nhóm J2TEAM Community trên Facebook đấy! 
============================================================
4. giờ bạn hãy đưa ra so sánh chi tiết về async-await, promise, callback đi:
    Tất nhiên, bây giờ mình sẽ so sánh chi tiết về từng khái niệm này để bạn có thể hiểu rõ hơn những điểm tương đồng và khác biệt giữa chúng. 
        ### Callbacks:
            - Khái niệm: Là hàm được truyền vào hàm khác như một đối số và được gọi lại sau tác vụ bất đồng bộ.
            - Ưu điểm: Đơn giản và dễ hiểu cho những tác vụ đơn lẻ.
            - Nhược điểm: Dễ dẫn đến "callback hell" khi lồng nhiều tác vụ. Khó quản lý lỗi và làm cho code khó bảo trì, khó đọc.
            - Ví dụ sử dụng:
                
                fs.readFile(filePath, function(err, data) {
                    if (err) {
                        console.error('Error:', err);
                    } else {
                        console.log('File data:', data);
                    }
                });
        
        ### Promises:
            - Khái niệm: Là đối tượng đại diện cho giá trị cuối cùng của tác vụ bất đồng bộ và trạng thái của tác vụ đó.
            - Ưu điểm: Tránh được callback hell bằng cách sử dụng .then() và .catch() cho tổ chức mã nguồn rõ ràng và kiểm soát lỗi tốt hơn.
            - Nhược điểm: Cần phải hiểu rõ cách hoạt động để xử lý lỗi hiệu quả; .then() có thể vẫn cần chuỗi khi có nhiều tác vụ liên tiếp.
            - Ví dụ sử dụng:
                
                getJSON(apiUrl).then(data => {
                    console.log('Success:', data);
                }).catch(error => {
                    console.error('Error:', error);
                });

        ### Async/Await:
            - Khái niệm: Cú pháp mới trong JavaScript ES2017 giúp viết code bất đồng bộ một cách rõ ràng, dễ đọc hơn như code đồng bộ thông qua việc sử dụng các từ khóa async và await.
            - Ưu điểm: Code trở nên sạch sẽ, dễ đọc; xử lý lỗi giống như cú pháp try/catch thông thường; giải quyết vấn đề của callback hell và phức tạp của promises.
            - Nhược điểm: Có thể dẫn đến các tình huống chờ không cần thiết nếu không được sử dụng đúng cách; await chỉ hoạt động trong phạm vi của async function.
            - Ví dụ sử dụng:
                
                async function fetchUser() {
                    try {
                        let response = await fetch(apiUrl);
                        let data = await response.json();
                        console.log('User data:', data);
                    } catch (error) {
                        console.error('Error:', error);
                    }
                }

        ### Kết luận và Khi nào nên sử dụng:
            - Callbacks: Nhanh chóng và trực tiếp cho tác vụ bất đồng bộ đơn giản và đơn lẻ.
            - Promises: Khi cần tổ chức và quản lý nhiều tác vụ bất đồng bộ, hoặc khi cần thiết lập một chuỗi các thao tác.
            - Async/Await: Khi bạn muốn mã nguồn trở nên giống như đồng bộ và dễ đọc, thích hợp khi làm việc với nhiều tác vụ bất đồng bộ làm cho mã code trở nên phức tạp.
    Cuối cùng, việc lựa chọn giữa async/await, promises, hay callbacks phụ thuộc vào nhu cầu cụ thể của tác vụ bạn đang làm và sở thích lập trình.
    Hãy chọn phương pháp phù hợp nhất để việc code trở nên hiệu quả và dễ dàng hơn nhé!
============================================================
5. như vậy tôi có thể hiểu là cả 3 khái niệm callback, promise, async-await chúng ta đều phải tạo 1 function và đưa các thao tác bất đồng bộ vào trong đó đúng không?
    Chính xác đấy! Các khái niệm callback, promise, và async/await đều liên quan đến việc bao bọc (wrapping) các hoạt động bất đồng bộ trong một hàm để quản lý việc thực thi của chúng.
    Dưới đây là cách chúng ta thường sử dụng từng khái niệm:

        1. Callbacks: Bạn truyền một hàm (callback function) vào hàm khác như một đối số. Hàm này sau đó sẽ gọi lại hàm callback của bạn khi tác vụ bất đồng bộ hoàn thành.

        2. Promises: Bạn tạo ra một đối tượng Promise, nơi bạn đặt các tác vụ bất đồng bộ.
           Đối tượng Promise này có hai phương thức .then() và .catch() mà bạn sử dụng để xử lý giá trị trả về thành công hoặc lỗi sau khi tác vụ bất đồng bộ hoàn thành.

        3. Async/Await: Bạn khai báo một hàm với từ khóa async, điều này cho biết hàm sẽ làm việc với các hoạt động bất đồng bộ.
           Bên trong hàm async, bạn sử dụng từ khóa await trước một hàm trả về Promise để "đợi" kết quả của nó mà không chặn luồng chính,
           cho phép bạn viết mã như thể nó đang thực hiện một cách đồng bộ.

        Ví dụ bằng mã cho từng khái niệm:

            Callback:
                function thuThaoTacBatDongBo(callback) {
                    // Tác vụ bất đồng bộ
                    setTimeout(() => {
                        callback('Hoàn thành tác vụ');
                    }, 1000);
                }

                thuThaoTacBatDongBo(function(ketQua) {
                    console.log(ketQua); // In ra "Hoàn thành tác vụ"
                });

            Promise:
                function thuThaoTacBatDongBo() {
                    return new Promise((resolve, reject) => {
                        // Tác vụ bất đồng bộ
                        setTimeout(() => {
                        resolve('Hoàn thành tác vụ');
                        }, 1000);
                    });
                }

                thuThaoTacBatDongBo().then(ketQua => {
                    console.log(ketQua); // In ra "Hoàn thành tác vụ"
                    }).catch(loi => {
                    console.error(loi);
                });

            Async/Await:
                async function xuLyThaoTacBatDongBo() {
                    let ketQua = await thuThaoTacBatDongBo(); // thuThaoTacBatDongBo phải trả về Promise
                    console.log(ketQua); // In ra "Hoàn thành tác vụ" sau khi Promise resolve
                }

                xuLyThaoTacBatDongBo();

    Tất cả đều đạt được cùng một mục tiêu là quản lý thực hiện của các thao tác bất đồng bộ, nhưng chúng đưa ra phương pháp tiếp cận khác nhau
    và mỗi phương pháp có những đặc điểm cụ thể để thích nghi với các tình huống khác nhau..accessToken Nói một cách vui vẻ thì, nếu bạn thích tiệc tùng,
    thì callbacks giống như tự pha chế tại bữa tiệc, promises là đặt trước cocktail, 
    và async/await là hệ thống phục vụ tự động mang đến cho bạn đồ uống ngay khi bạn cần, mà không cần đợi chờ.

##################################################################
Khi nói đến mở rộng jQuery, có vài phương pháp chính chúng ta có thể sử dụng để tùy biến hoạt động của jQuery,
thêm các phương thức của riêng mình, hoặc tạo plugin. Dưới đây là một số cách phổ biến:

### 1. jQuery Plugins
    Một cách phổ biến để mở rộng jQuery là viết plugin. Plugin giúp bạn tái sử dụng code, dễ bảo trì hơn và có thể chia sẻ với người khác.
        - Cách viết truyền thống:
            (function($) {
                $.fn.highlight = function(color) {
                    this.css('background-color', color);
                    return this; // Để chain các phương thức khác
                };
            })(jQuery);

            // Sử dụng plugin này
            $('#myElement').highlight('yellow');


        - Cách viết ngắn gọn:
            $.fn.highlight = function(color) {
                this.css('background-color', color);
                return this; // Để chain các phương thức khác
            };

            // Sử dụng plugin này
            $('#myElement').highlight('yellow');

### 2. jQuery Namespace Extensions
    Bạn có thể mở rộng các hàm jQuery bằng cách thêm vào namespace của nó.
        - Cách viết truyền thống:
            (function($) {
                $.extend({
                    alertMessage: function(message) {
                        alert(message);
                    }
                });
            })(jQuery);

            // Sử dụng hàm này
            $.alertMessage('Hello, World!');


        - Cách viết ngắn gọn:
            $.extend({
                alertMessage: function(message) {
                    alert(message);
                }
            });

            // Sử dụng hàm này
            $.alertMessage('Hello, World!');

### 3. Thêm phương thức tùy biến vào jQuery
    Bạn có thể thêm phương thức của mình vào jQuery mà không cần phải viết plugin hoàn chỉnh.
        - Cách viết truyền thống:
            (function($) {
                $.fn.changeText = function(newText) {
                    this.text(newText);
                    return this; // Để chain các phương thức khác
                };
            })(jQuery);

            // Sử dụng phương thức tùy biến này
            $('#myElement').changeText('New Text');

        - Cách viết ngắn gọn:
            $.fn.changeText = function(newText) {
                this.text(newText);
                return this; // Để chain các phương thức khác
            };

            // Sử dụng phương thức tùy biến này
            $('#myElement').changeText('New Text');

### 4. Sử dụng $.proxy
    Sử dụng $.proxy để giữ nguyên ngữ cảnh (this) khi gọi các hàm bên trong sự kiện.
        - Cách viết truyền thống:
            (function($) {
                function MyObject() {
                    this.value = "Hello";
                    $('#myButton').on('click', $.proxy(this.onClick, this));
                }

                MyObject.prototype.onClick = function() {
                    alert(this.value);
                };
                
                new MyObject();
            })(jQuery);

        - Cách viết ngắn gọn:
            function MyObject() {
                this.value = "Hello";
                $('#myButton').on('click', $.proxy(this.onClick, this));
            }

            MyObject.prototype.onClick = function() {
                alert(this.value);
            };

            new MyObject();

### 5. Thêm các phương thức tiện ích với $.extend
    Bạn có thể mở rộng không chỉ object $.fn mà còn cả object chính jQuery để thêm các phương thức tiện ích.
        - Cách viết truyền thống:
            (function($) {
                $.extend({
                    square: function(n) {
                        return n * n;
                    }
                });
            })(jQuery);

            // Sử dụng phương thức tiện ích này
            console.log($.square(5)); // 25

        - Cách viết ngắn gọn:
            $.extend({
                square: function(n) {
                    return n * n;
                }
            });

            // Sử dụng phương thức tiện ích này
            console.log($.square(5)); // 25

Qua các cách mở rộng trên, bạn có thể thấy tính linh hoạt của jQuery trong việc tùy biến và mở rộng chức năng của nó.
###############################################################
Cách viết jQuery truyền thống và hiện đại:
### 1. Document Ready
    - jQuery truyền thống:
        $(document).ready(function() {
            // Code chạy khi DOM sẵn sàng
        });

    - jQuery ngắn gọn:
        $(function() {
            // Code chạy khi DOM sẵn sàng
        });
Tóm lại, cách viết jQuery ngắn gọn chủ yếu là loại bỏ việc lặp lại tên hàm jQuery nhiều lần bằng cách dùng ký tự $ thay thế và tận dụng các hàm có sẵn
###############################################################
Một số cách mở rộng object trong javascript.

Giả sử bạn có hai object sau:
    let exportsItem = {
        name: "Táo",
        color: "Đỏ"
    };

    let libraryItem = {
        price: 20000,
        country: "Việt Nam",
        color: "Xanh"
    };

###1. Sử dụng $.extend() của jQuery:
    Nếu trong file javascript có import thư viện jQuery thì ta có thể sử dụng $.extend() của jQuery  
    được sử dụng để ghép nối hoặc mở rộng các thuộc tính từ một hoặc nhiều object nguồn vào một object đích.
    Nếu bạn sử dụng jQuery, bạn có thể ghép nối hai object này như sau:

        let mergedItem = $.extend({}, exportsItem, libraryItem);
        console.log(mergedItem);

    Kết quả sẽ là một object mới mergedItem chứa tất cả thuộc tính từ cả hai object, với thuộc tính color từ libraryItem sẽ đè lên thuộc tính tương ứng trong exportsItem:
        {
            name: "Táo",
            color: "Xanh",
            price: 20000,
            country: "Việt Nam"
        }

###2. Sử dụng Object.assign() trong JavaScript ES6 và mới hơn:

    Bạn có thể đạt được kết quả tương tự mà không cần jQuery bằng cách sử dụng Object.assign():

        let mergedItem = Object.assign({}, exportsItem, libraryItem);
        console.log(mergedItem);

Kết quả cũng sẽ giống như khi sử dụng $.extend():

        {
            name: "Táo",
            color: "Xanh",
            price: 20000,
            country: "Việt Nam"
        }

###3. Sử dụng Spread Operator {...} trong JavaScript ES6 và mới hơn:
    Một cách khác để kết hợp object mà không cần jQuery là sử dụng spread operator:

        let mergedItem = {...exportsItem, ...libraryItem};
        console.log(mergedItem);

    Cũng như hai phương pháp trên, kết quả sẽ là:
        {
            name: "Táo",
            color: "Xanh",
            price: 20000,
            country: "Việt Nam"
        }
Như vậy, bạn có thể thấy cả Object.assign() và spread operator {...} trong JavaScript cung cấp một cách
mạnh mẽ để mở rộng hoặc kết hợp các object mà không cần dùng đến thư viện ngoại vi như jQuery.
Trong các đoạn code trên:
    - {} là object đích mới, nó trống rỗng. Điều này đảm bảo rằng không có thuộc tính nào của exports[item] gốc bị thay đổi.
    - exports[item] là object nguồn đầu tiên được ghép vào object mới. Nếu exports[item] chưa được định nghĩa, nó sẽ được tạo ra như một object rỗng.
    - library[item] là object nguồn thứ hai, và các thuộc tính của nó cũng sẽ được ghép nối vào object mới.

    Phương thức $.extend không chỉ ghép các thuộc tính từ library[item] vào exports[item] mà còn ghép đè lên các thuộc tính có tên giống nhau.
    Điều này không ảnh hưởng đến đối tượng $ (jQuery) mà chỉ thay đổi object exports[item].
#################################################################
Vậy là bạn muốn nhìn thấy sự tiến hóa trong cách Javascript mở rộng objects theo từng phiên bản? 
Dễ thôi! Let’s embark on a tiny time travel through the Javascript universe!

### ES5 và trước đó

    Trong thời kỳ "cổ đại", Javascript không có một syntax dành riêng cho việc mở rộng objects. Nhưng chúng ta có thể dùng các chiến lược "truyền thống", ví dụ đoạn code "thủ công" sau:
        var original = { cheese: 'Cheddar', wine: 'Merlot' };
        var additional = { bread: 'Baguette', cheese: 'Camembert' };
        for (var key in additional) {
            if (additional.hasOwnProperty(key)) {
                original[key] = additional[key];
            }
        }
        // Output: original = { cheese: 'Camembert', wine: 'Merlot', bread: 'Baguette' }

    Phương pháp này đơn giản nhưng nó không xử lý các thuộc tính đặc biệt như property descriptors, getters/setters hay đối tượng có thể sealed/frozen.

### ES5: Object.create

    Object.create cho phép tạo object mới với prototype được chỉ định, một bước đi xa hơn so với sự chỉ định thuộc tính trực tiếp.
        var base = { cheese: 'Cheddar', wine: 'Merlot' };
        var extended = Object.create(base);
        extended.bread = 'Baguette';
        // 'extended' object có 'bread', cùng với 'cheese' và 'wine' từ 'base' qua prototype chain.

### ES5: Object.keys và forEach

    Sự kết hợp của Object.keys và Array.prototype.forEach cũng được sử dụng để mở rộng objects:
        var base = { cheese: 'Cheddar', wine: 'Merlot' };
        var extension = { bread: 'Baguette', cheese: 'Camembert' };
        Object.keys(extension).forEach(function(key) {
            base[key] = extension[key];
        });
        // base = { cheese: 'Camembert', wine: 'Merlot', bread: 'Baguette' }

### ES5.1: Object.assign

    Với ES5.1, "quy trình phẫu thuật mở rộng" trở nên tự động hóa hơn:
        var base = { cheese: 'Cheddar', wine: 'Merlot' };
        var extensions = { bread: 'Baguette', cheese: 'Camembert' };
        Object.assign(base, extensions);
        // Output: base = { cheese: 'Camembert', wine: 'Merlot', bread: 'Baguette' }

    Object.assign là bước đầu tiên đến việc mở rộng objects một cách "native" mà không cần phải viết các loops "for-in" nữa.

### ES6 (ES2015): Spread Operator
    À, cứu tinh của làng Javascript, Spread Operator làm cho việc mở rộng objects trở nên sành điệu và đơn giản đến bất ngờ:
        const base = { cheese: 'Cheddar', wine: 'Merlot' };
        const extension = { bread: 'Baguette', cheese: 'Camembert' };
        const combined = { ...base, ...extension };
        // Output: combined = { cheese: 'Camembert', wine: 'Merlot', bread: 'Baguette' }
    Với Spread Operator, việc mở rộng và kết hợp các objects trở thành một đoạn mã sạch sẽ và dễ đọc hơn hẳn.

### So sánh
    - For-in loops (trước ES5): Được sử dụng từ đầu, nhưng cần kiểm tra hasOwnProperty và không đảm bảo kết quả đúng đắn cho các thuộc tính đặc biệt.
    - Object.create (ES5): Tạo prototype chain nhưng không trực tiếp mở rộng object.
    - Object.keys và forEach (ES5): Cải thiện việc sử dụng loops bằng cách cung cấp array of keys mà không cần kiểm tra hasOwnProperty.
    - Object.assign (ES5.1): Mở rộng object một cách native và tự động, dễ sử dụng hơn, nhưng không làm việc với getters/setters.
    - Spread Operator (ES6): Mớ lạ và mở rộng object một cách sạch sẽ, hiểu được getters/setters và là preferred solution trong nhiều trường hợp.
    Thú vị chứ? Như thấy được, mỗi bước tiến trên hành trình Evolution của Javascript đều mang lại các cách thú vị và hiệu quả hơn để xử lí những công việc!

#####################################################
vậy đoạn code này có ý nghĩa gì, bạn có thể lấy ví dụ được không:
'use strict';

module.exports = function (include) {
    if (typeof include === 'function') {
        include();
    } else if (typeof include === 'object') {
        Object.keys(include).forEach(function (key) {
            if (typeof include[key] === 'function') {
                include[key]();
            }
        });
    }
};

Đoạn code bạn cung cấp là một mô-đun Node.js sử dụng để kiểm tra tham số include truyền vào khi hàm được gọi. Dựa vào kiểu của include, hàm thực hiện các hành động sau:
- Nếu include là một hàm, nó sẽ được thực thi ngay lập tức.
- Nếu include là một object (không phải một mảng), mỗi thuộc tính trong object đó sẽ được kiểm tra. Nếu thuộc tính là một hàm, hàm đó sẽ được gọi.

Cùng xem qua một vài ví dụ nhé:

### Ví dụ 1: Sử dụng include là một hàm
    'use strict';
    // Giả sử đây là nội dung của file module.js
    module.exports = function (include) {
        if (typeof include === 'function') {
            include();
        } else if (typeof include === 'object') {
            Object.keys(include).forEach(function (key) {
                if (typeof include[key] === 'function') {
                    include[key]();
                }
            });
        }
    };

    // File sử dụng mô-đun
    const includeHandler = require('./module');

    includeHandler(function() {
    console.log('Hello, Function!');
    });

    Kết quả khi thực thi sẽ in ra: Hello, Function!

### Ví dụ 2: Sử dụng include là một object chứa hàm
    'use strict';

    // Giả sử đây là nội dung của file module.js
    module.exports = function (include) {
        if (typeof include === 'function') {
            include();
        } else if (typeof include === 'object') {
            Object.keys(include).forEach(function (key) {
                if (typeof include[key] === 'function') {
                    include[key]();
                }
            });
        }
    };

    // File sử dụng mô-đun
    const includeHandler = require('./module');

    includeHandler({
        greet: function() {
            console.log('Hello, Object!');
        },
        bye: function() {
            console.log('Goodbye, Object!');
        }
    });

    Kết quả khi thực thi sẽ in ra:
        Hello, Object!
        Goodbye, Object!

    Ở ví dụ 2, chúng ta thấy đoạn code kiểm tra mỗi thuộc tính trong object include. 
    Nếu thuộc tính đó là một hàm, hàm đó sẽ được thực thi. 
Đoạn mã này rất hữu ích trong các trường hợp bạn muốn cung cấp một API linh hoạt cho mô-đun của mình,
cho phép người dùng truyền vào một hàm duy nhất hoặc một object chứa nhiều hàm để thực thi.

#####################################################
2 thư viện sinon và mocha là gì trong ứng dụng javascript
### Sinon
    Sinon là một thư viện JavaScript được sử dụng cho việc thực hiện test doubles, bao gồm stubs, spies, và mocks trong quá trình kiểm thử.
    Nó giúp dễ dàng giả lập các hành vi của các phần khác nhau trong ứng dụng để có thể kiểm tra các chức năng một cách độc lập.
        - Spies: Theo dõi các hàm, bao gồm việc theo dõi một hàm đã được gọi bao nhiêu lần, với những đối số gì và giá trị trả về là gì.
        - Stubs: Tương tự như Spies nhưng cho phép "đè" hành vi mặc định của hàm bằng cách thiết lập giá trị trả về, ném exception, etc.
        - Mocks: Kết hợp các khả năng của spies và stubs nhưng với một cách tiếp cận khác nhau về cách khởi tạo và kiểm tra.

### Mocha
    Mocha là một framework kiểm thử cho JavaScript, chạy trên Node.js và trình duyệt, giúp làm cho kiểm thử đồng bộ và bất đồng bộ trở nên dễ dàng.
    Mocha cung cấp một môi trường kiểm thử linh hoạt thông qua việc sử dụng describe và it blocks,
    cho phép bạn mô tả các trường hợp kiểm thử và kỳ vọng kết quả một cách rõ ràng và mạch lạc.

### Ví dụ kết hợp Sinon và Mocha
    Giả sử bạn có một module notify.js với nội dung:
        // notify.js
        function sendEmail(email, message) {
            // Logic gửi email
            console.log(Gửi email đến ${email} với nội dung: "${message}");
        }

        function notifyUser(user) {
            const message = "Hello there";
            sendEmail(user.email, message);
        }

        module.exports = { notifyUser, sendEmail };

        Chúng ta muốn kiểm thử hàm notifyUser để đảm bảo rằng nó gọi đúng hàm sendEmail với các tham số đúng. Dưới đây là cách bạn có thể thực hiện điều đó với Mocha và Sinon:

    1. Tạo File Kiểm Thử:
        // notify.test.js
        const sinon = require('sinon');
        const { expect } = require('chai');
        const { notifyUser, sendEmail } = require('./notify');

        describe('notifyUser function', function() {
            it('should call sendEmail with user email and correct message', function() {
                // Tạo stub cho hàm sendEmail
                const sendEmailStub = sinon.stub().returns("Email sent");
                // Ghi đè hàm sendEmail trong module exports
                sinon.replace(exports, 'sendEmail', sendEmailStub);

                const user = { email: 'user@example.com' };
                notifyUser(user);

                // Kiểm tra xem stub có được gọi đúng không
                sinon.assert.calledWith(sendEmailStub, user.email, "Hello there");
                // Khôi phục lại hành vi mặc định của hàm sau khi test
                sinon.restore();
            });
        });

    Ở đây, sinon.stub() được sử dụng để tạo ra một "stub" cho sendEmail, cho phép chúng ta giả lập việc gọi hàm này mà không cần phải thực sự thực thi logic bên trong nó.
    Chúng ta sau đó ghi đè lên hàm sendEmail trong module.exports (cần chú ý rằng, việc này có thể yêu cầu cấu trúc code và xuất module của bạn phải phù hợp).

    Dùng sinon.assert.calledWith() để kiểm tra xem stub đã được gọi với các tham số đúng hay không, và sinon.restore() để khôi phục lại mọi thứ sau khi kiểm thử hoàn tất.

    Để thực hiện kiểm thử, bạn chạy lệnh mocha notify.test.js (giả sử bạn đã cài đặt Mocha toàn cục), hoặc cấu hình script trong package.json để chạy Mocha.

    Lần này hy vọng rằng ví dụ sẽ chính xác và hữu ích hơn cho bạn! Và đừng quên, thử nghiệm và kiểm thử là chìa khóa để sản phẩm phần mềm chất lượng. Tiếp tục cày coding nhé!

### Giới thiệu về Chai và cách sử dụng
    Lệnh const { expect } = require('chai'); là một ví dụ của việc sử dụng thư viện Chai cùng với câu lệnh require trong Node.js
    để nhập thư viện và sử dụng một trong những API kiểm thử của nó, trong trường hợp này là expect.

    Chai là một thư viện giả định (assertion library) phổ biến được sử dụng trong kiểm thử JavaScript.
    Nó cung cấp ba kiểu giao diện (stylish) giả định khác nhau: Assert, Expect, và Should, giúp viết các giả định kiểm thử một cách linh hoạt và bản năng.
        1. Assert: Sử dụng cách viết giống các hàm kiểm tra giá trị trong các ngôn ngữ lập trình truyền thống.
        2. Expect/Should: Cung cấp một cách viết kiểm thử theo ngữ cảnh tự nhiên hơn, giúp code dễ đọc và dễ hiểu.

    - Sử dụng Expect
        Expect cho phép bạn tạo ra các giả định kiểm thử về giá trị, kiểu dữ liệu, hoặc hành vi của code một cách rõ ràng.
        Nó thường được sử dụng cùng với các thư viện kiểm thử như Mocha hoặc Jest để kiểm tra độ chính xác của kết quả code.

        Ví dụ cơ bản sử dụng expect:
            const expect = require('chai').expect;
            describe('mathematical operations', function() {
                it('should add numbers correctly', function() {
                    const number1 = 2;
                    const number2 = 3;
                    const sum = number1 + number2;
                    // Giả định rằng 'sum' phải bằng 5
                    expect(sum).to.equal(5);
                });
            });
        Trong ví dụ này, expect(sum).to.equal(5); kiểm tra xem biến sum có giá trị bằng 5 không. Nếu không, thì test case này sẽ thất bại.

        - Lợi ích của Expect
            - Rõ ràng và tự nhiên: Cú pháp của expect rất gần với ngôn ngữ tự nhiên, làm cho các giả định dễ đọc và hiểu.
            - Linh hoạt: Có thể được sử dụng để kiểm thử đa dạng các kiểu giá trị và hành vi.
            - Mạnh mẽ: Hỗ trợ nhiều loại giả định và kiểm thử sâu.

#########################################################
tôi có một thẻ input, tôi muốn rằng khi focus vào thẻ input này thì sẽ hiển thị ra một list suggestion được render từ api và có thể chọn được,
khi không focus nữa thì cái list suggestion sẽ mất đi. yêu cầu là dùng jquery để làm:

Để tạo một list suggestion (gợi ý) cho một thẻ input khi focus và ẩn nó khi không focus nữa, bạn có thể làm theo các bước sau đây sử dụng jQuery:

1. Tạo HTML:
    Thêm một thẻ input và một container để hiển thị các suggestion.
        <input type="text" id="inputSuggestion" placeholder="Start typing...">
        <div id="suggestionBox" style="display:none;"></div>

2. CSS (tùy chọn):
    Style cho #suggestionBox để nó trông như một list suggestion.
        #suggestionBox {
            position: absolute;
            background-color: #fff;
            border: 1px solid #ddd;
            z-index: 1000;
            /* Other styles as needed */
        }

3. jQuery:
    Sử dụng sự kiện focus và focusout để xử lý việc hiển thị và ẩn suggestion box. Sử dụng $.ajax hoặc $.get để làm việc với API và lấy suggestions.
        $(document).ready(function() {
            $('#inputSuggestion').on('focus', function() {
                // Call API để lấy suggestions
                $.ajax({
                    url: 'YOUR_API_ENDPOINT', // Endpoint API của bạn
                    dataType: 'json', // Dạng dữ liệu trả về, thường là JSON
                    success: function(data) {
                        // Xử lý dữ liệu trả về từ API để tạo suggestions
                        var suggestions = ''; // Tạo một chuỗi HTML để chứa suggestions
                        $.each(data, function(index, item) {
                        // item là giá trị suggestion từ API
                        suggestions += '<div class="suggestion-item">' + item + '</div>';
                        });
                        // Thêm suggestions vào suggestionBox và hiển thị nó
                        $('#suggestionBox').html(suggestions).show();
                    }
                });
            }).on('focusout', function() {
                // Ẩn box khi không focus
                setTimeout(function() { // Sử dụng setTimeout để tránh ẩn ngay khi click
                $('#suggestionBox').hide();
                }, 300); // Delay một chút để có thể click chọn được suggestion
            });

            // Xử lý khi click chọn một suggestion
            $(document).on('click', '.suggestion-item', function() {
                var value = $(this).text(); // Lấy giá trị được chọn
                $('#inputSuggestion').val(value); // Đặt giá trị cho thẻ input
                $('#suggestionBox').hide(); // Ẩn suggestion box sau khi chọn
            });
        });
    Nhớ cập nhật YOUR_API_ENDPOINT với endpoint thực tế của API của bạn. Mã trên đây chỉ là một ví dụ cơ bản,
    bạn có thể cần điều chỉnh nó cho phù hợp với API và chức năng cụ thể mà bạn cần thực hiện.