- Node.js treats each file in a Node project as a module that can export values and functions from the file.
- Declare Objects with const
        - Declaring objects with const will prevent any accidental change of type:
            let car = {type:"Fiat", model:"500", color:"white"};
            car = "Fiat";      // Changes object to string

            const car = {type:"Fiat", model:"500", color:"white"};
            car = "Fiat";      // Not possible
            car.newProperty = "newValue"; // it's ok
            car['newProperty1'] = "newValue1"; // it's ok
    - Declare Arrays with const:
        - Declaring arrays with const will prevent any accidential change of type:
            let cars = ["Saab", "Volvo", "BMW"];
            cars = 3;    // Changes array to number

            const cars = ["Saab", "Volvo", "BMW"];
            cars = 3;    // Not possible
            cars.push("newValue") // It's ok
            cars[4] = "Toyota"; // It's ok
#############################################
- Comparison table for CommonJS and ES Modules
    - Module Loading:
        - CommonJS: Synchronous
        - ES Module: Asynchronous
    - Import/Export:
        - CommonJS: 'require'/'exports'
        - ES Module: 'import'/'export'
    - Caching
        - CommonJS: Cached
        - ES Module: Not cached by default
    - Use Case
        - CommonJS: Server-side
        - ES Module: Client-side and server-side
    - Dynamic Import
        - CommonJS: Not supported
        - ES Module: Supported
Node.js module.exports vs. exports. áp dụng nếu sử dụng CommonJS
    - exports và module.exports chứ không phải là export nhé các bạn, export là cho bên ES module.
      Nhiều bạn hay viết thiếu chữ “s” lắm ấy.
      Trong Javascript thì có cái từ khóa export nhưng trong NodeJS thì chưa đâu.
    - Furthermore, you will come across three types of modules in Node.js:
        - Core Modules: These are built-in modules like http, fs, etc.
        - Local Modules: These modules are locally created by the programmer.
        - Third-Party Modules: These modules are available to use after installation
          using NPM(Node Package Manager) like: express, mongoose etc.
    - Cơ chế Wrapping của NodeJS là gì?
        - When we call require in our application, the new module is created.
          Its initial value is an empty object literal {}. Before the referenced module’s code
          is executed, Node.js will wrap it with the module wrapper function. 
          Let's look briefly into the structure of the module wrapper function:
            (function(exports, require, module, __filename, __dirname) { 
                // Module code actually lives in here 
            });
        - Using the module wrapper function, Node.js keeps top-level variables
          (defined with var, const, or let) scoped to the module rather than as the global
          object. It also provides access to the exported module-specific variables for use
          in our application.
        - The variables __filename and __dirname in the module wrapper function contain the
          absolute filename and directory path of the module.
        - Now let's look into module.exports, module.exports is the object reference that gets
          returned when we make require() calls in our application. By module. exports,
          we can get access to module-specific variables that don’t leak out to the global object.
    - module.exports và exports khác nhau như thế nào?
        - Trước hết thì module.exports và exports trỏ tới cùng một Object, là một Object rỗng.
        - Tuy nhiên, chỉ có một thằng module.exports là cái thật sự được export khi mình require nó thôi. 
          Còn thằng exports thì không phải. Nó chỉ là một reference tới thằng module.exports thôi.
            - ví dụ:
                module.exports.name = "Nguyen";
                exports.name = "Nguyen";
                console.log(module.exports); //{ name: 'Nguyen' }
                console.log(exports); //{ name: 'Nguyen' }
                console.log(module.exports === exports); //true
            - Ở đây có thể thấy hai thằng này chỉ thay đổi cái properties của cái Object ban đầu
              (là Object rỗng ban đầu). Nên ở đây, hai thằng này vẫn là cùng một Object.
            - Tuy nhiên, nếu như sửa lại:
                module.exports = {
                    name: "Nguyen"
                };
                exports = {
                    name: "Nguyen"
                };
                console.log(module.exports === exports); // false
            - Hai thằng này là hai cái Object khác nhau, vì mình là assign lại giá trị cho thằng
              exports (Mình dùng dấu =).Kết quả sẽ là false
            - Mình chứng minh thêm như sau:
                - Trong file export.js mình viết: 
                    exports = {
                        name: "Nguyen"
                    };
                - Sau đó, trong file index.js mình viết
                    const object = require("./export");
                    console.log(object);
                - Thì kết quả là {}
            - Vì chỉ là thằng module.exports mới là thằng thật sự được export
              (Và mặc định nó là một Object rỗng). Còn thằng exports thì không.
        - Vậy thì khi nào sử dụng thằng exports?
            - Dùng thằng exports chỉ khi nào mình muốn add thêm một cái properties vào
              cái Object mặc định của nó. Ví dụ như thay vì viết;
                module.exports.x = 1;
                module.exports.y = 2;
                module.exports.z = 3;
            - Thì có thể viết thành như sau cho nó ngắn và tiện hơn.
                exports.x = 1;
                exports.y = 2;
                exports.z = 3;
    - Kết luận:
        - Luôn sử dụng module.exports khi muốn export một cái gì đó.
          Đừng lăn tăn sử dụng exports là gì cho rối rắm hết cả lên.  
##################################
JavaScript Object Rest Properties
    - ECMAScript 2018 added rest properties.
    - This allows us to destruct an object and collect the leftovers onto a new object:
        Example
            let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
            x; // 1
            y; // 2
            z; // { a: 3, b: 4 }
############################################
Arguments javascript dễ hiểu mà sao họ giải thích dài thế
    - Thật ra nó rất dễ hiểu, việc thông qua những ví dụ dưới đây là hiểu rồi. 
      Nhưng đến giờ tôi không biết tại sao có nhiều bài viết giải thích dài dòng đến như vậy. Hãy xem ví dụ:
        function add (num1, num2) {
            // logs [num1, num2] (with their values)
            console.log(arguments); [num1, num2]
            // Lấy ra param đầu tiên 
            console.log(arguments[0]); // num1
            // Lấy ra param thứ 2
            console.log(arguments[1]); // num2
            // ...
        }
    - Ví dụ này chúng tôi tạo một Regular Function. Đừng nói với tôi Regular Function là gì? đấy nhé. Vậy thôi đơn giản gọn nhẹ,
      arguments giúp chúng ta lấy được tham số truyền vào một cách dễ dàng. Ở đây có ý kiến cho rằng vậy "khác gì cách lấy tham số đâu?" 
    - OK, ví dụ tiếp theo sẽ khác đấy.
        function add () {
            // Set biến tổng
            let total = 0;
            // Cộng đồn mỗi params
            Array.from(arguments).forEach(function (num) {
                total += num;
            });
            // Return to the total
            return total;
        }
    - Tiếp theo chúng ta sử dụng ví dụ này như sau:
        // returns 0
        add();
        // returns 4
        add(4);
        // returns 36
        add(4, 2, 11, 19);
    - Có gì khác chưa? Khác đúng không? Điều này đặc biệt hữu ích nếu bạn muốn cho phép một số lượng không giới hạn các đối số được chuyển vào hàm của bạn.
    - Arguments javascript sử dụng nên chú ý
    - Khi sử dụng Arguments trong javascript cũng nên chú ý một điều cũng hơi quan trọng đó là arguments
      giống như một Array nhưng nó không thực sự là một Array. Nếu nó là một Array thì tất cả 10 method của Array đều có thể sử dụng được. 

    - Nhưng ví dụ trên thì chúng ta phải nhờ đến người anh em Array.from trước sau đó mới sử dụng forEach(). 
      Vậy Arguments thực sự là gì? Arguments có thể nói chính là Array-like.
############################################
const
    The const declaration declares block-scoped local variables.
    The value of a constant can't be changed through reassignment using the assignment operator, but if a constant is an object,
    its properties can be added, updated, or removed.
    - const in objects and arrays
        - const also works on objects and arrays. Attempting to overwrite the object throws an error "Assignment to constant variable".
            - example: 
                - it is throw an error:
                    //object
                    const MY_OBJECT = { key: "value" };
                    MY_OBJECT = { OTHER_KEY: "value" };
                    //array
                    const MY_ARRAY = [];
                    MY_ARRAY = ["B"];
                - However, object keys are not protected, so the following statement is executed without problem.
                    MY_OBJECT.key = "otherValue";
                - Still, it's possible to push items into the array and thus mutate it.
                    MY_ARRAY.push("A"); // ["A"]
        - Declaration with destructuring
            - The left-hand side of each = can also be a binding pattern. This allows creating multiple variables at once.
                const result = /(a+)(b+)(c+)/.exec("aaabcc");
                const [, a, b, c] = result;
                console.log(a, b, c); // "aaa" "b" "cc"
            - But if we change the values of the variables above, it throw an error: Uncaught TypeError: Assignment to constant variable.
#############################################
Giải thích về Destructuring, Rest Parameters, và Spread Syntax trong javascript
    - Destructuring javascript là gì?
        - Destructuring là một cú pháp cho phép bạn gán các thuộc tính của một Object hoặc một Array. 
          Điều này có thể làm giảm đáng kể các dòng mã cần thiết để thao tác dữ liệu trong các cấu trúc này. 
          Có hai loại Destructuring: Destructuring Objects và Destructuring Arrays
            - Destructuring Objects:
                - Destructuring Objects cho phép bạn tạo ra một hay nhiều  new variables  sử dụng những property của một Objects. Xem ví dụ dưới đây:
                    - example: 
                        const note = {
                            id: 1,
                            website: 'anonystick.com',
                            date: '17/07/2014',
                        }
                    - Theo cách truyền thống thì chúng ta sẽ lấy ra những giá trị như cú pháp sau:
                        const id = note.id
                        const website = note.website
                        const date = note.date

                        console.log(id)
                        console.log(website)
                        console.log(date)
                    - Nhưng với việc sử dụng object destructuring chỉ với một dòng code ( Thủ thuật viết một dòng code ),
                      chúng ta có thể get được những giá trị ấy miễn là trùng tên của thuộc tính trong object là được:
                        // Destructure properties into variables
                        const { id, website, date } = note

                        console.log(id)
                        console.log(website)
                        console.log(date)
            - Destructuring Arrays:
                - Array destructuring cho phép bạn tạo ra một new variables bằng cách sử dụng giá trị mỗi index của Array. 
                  Xem ví dụ dưới đây cho nó dễ hiểu, chứ nói vậy chả hiểu đâu. 
                  Ta có một Array là thông tin về trang "blog javascript" được tạo ngày
                    - example: 
                        const date = ['2014', '17', '07']
                    - Như ở Object thì ta lần lượt lấy giá trị của mỗi item theo index
                        // Create variables from the Array items
                        const year = date[0]
                        const month = date[1]
                        const day = date[2]
                    - Nhưng giờ đây với việc sử dụng Array Destructuring thì công việc sẽ trở nên dế dàng hơn nhiều
                        // Destructure Array values into variables
                        const [year, month, day] = date

                        console.log(year) // 2014
                        console.log(month) // 17
                        console.log(day) // 07
    - Spread operator là gì?
        - Spread operator là ba dấu chấm ( ...), có thể chuyển đổi một mảng thành một chuỗi các tham số được phân tách bằng dấu phẩy.
          Nói cho dễ hiểu, nó giống như một cái xương và một cái xương sườn vậy, chia nhỏ một phần tử lớn thành những phần tử nhỏ riêng lẻ.
        - Nói về Spread tips javascript cũng đã có rất nhiều bài viết liên quan đến tính năng này. Spread syntax hay còn gọi là three dot (...)
          là một bổ sung hữu ích khác cho JavaScript để làm việc với các Arrays, Objects và các function calls. 
        - Hơn nữa Spread có thể tao ra một cấu trúc dữ liệu shallow copy để tăng tính thao tác dữ liệu. 
          Cũng giống như destructuring thì Spread cũng làm việc nhiều với Arrays và Objects.
        - Spread with Arrays:
            - Ví dụ trường hợp thức tế thì ta có thể merge array sử dụng concat.
                // Create an Array
                const tools = ['hammer', 'screwdriver']
                const otherTools = ['wrench', 'saw']

                // Concatenate tools and otherTools together
                const allTools = tools.concat(otherTools)

                console.log(allTools);

                //(4) [
                "hammer",
                "screwdriver",
                "wrench",
                "saw"
                ]
            - Nhưng giờ đây đã khác xưa rất nhiều rồi, hãy xem đây khi sử dụng Spread systax.
                // Unpack the tools Array into the allTools Array
                const allTools = [...tools, ...otherTools]
                console.log(allTools)
            - Còn rất nhiều thứ rất hay đang chờ đón bạn, chút nữa sẽ cung cấp đanh cho những ai đủ kiên nhẫn đọc hết bài viết này. 
                const ocean = ['🐙', '🦀'];
                const aquarium = [...ocean, '🐡']; // Add a single value
                const sushi = [...ocean, '🐡', '🍚']; // Add multiple values
                aquarium; // ['🐙', '🦀', '🐡']
                sushi; // ['🐙', '🦀', '🐡', '🍚']
                // Original Array Not Affected
                ocean; // ['🐙', '🦀']
        - Spread with Objects:
            - Khi sử dụng Spread thì chúng ta có thể copy và update một object như những gì mà Object.assign() đã làm
            - // Create an Object and a copied Object with Object.assign()
                const originalObject = { enabled: true, darkMode: false }
                const secondObject = Object.assign({}, originalObject)
                console.log(secondObject);//{enabled: true, darkMode: false}
            - Sử dụng Spread syntax thì sao? ez game.
                // Create an object and a copied object with spread
                const originalObject = { enabled: true, darkMode: false }
                const secondObject = { ...originalObject }
                console.log(secondObject);//{enabled: true, darkMode: false}
            - Spread with Function Calls
                - Giả sử chúng ta có một function như thế này
                    // Create a function to multiply three items
                    function multiply(a, b, c) {
                        return a * b * c
                    }
                - Nếu bình thường thì sao, thì add từng paramsx zô chứ sao:
                    multiply(1, 2, 3) ;// 6
                - Nhưng khi sử dụng Spread trong function calls thì rất đơn giản
                    const numbers = [1, 2, 3]
                    multiply(...numbers);//6
    - Rest Parameters là gì?
        - Tính năng cuối cùng bạn sẽ tìm hiểu trong bài viết này đó là Rest Parameters. Cú pháp này giống như Spread Syntax (...) nhưng có tác dụng ngược lại.
          Ví dụ Ví dụ, trong hàm restTest, nếu chúng ta muốn args là một mảng bao gồm một số lượng đối số không xác định, chúng ta có thể có:
            function restTest(...args) {
                console.log(args)
            }
            restTest(1, 2, 3, 4, 5, 6);// [1, 2, 3, 4, 5, 6]
    - Và đây là một bài viết về Rest Parameters và Spread Syntax dành cho những bạn kiên nhẫn đọc tới đây. 
      Ở bài viết này thì mọi điều sẽ được sáng tỏ, bạn sẽ phân biệt được giữa Rest Parameters và Spread Syntax. Và khi nào sử dụng chúng.

#############################################
- The Nullish Coalescing Operator (??)
    - The ?? operator returns the first argument if it is not nullish (null or undefined). 
      Otherwise it returns the second argument.
        - Example:
            let name = null;
            let text = "missing";
            let result = name ?? text;
            -> result: missing
- The Optional Chaining Operator (?.):
    - The ?. operator returns undefined if an object is undefined or null (instead of throwing an error).
    - Example:
        // Create an object:
        const car = {type:"Fiat", model:"500", color:"white"};
        // Ask for car name:
        document.getElementById("demo").innerHTML = car?.name;
        -> result: undefined
#############################################
JavaScript Object Properties
    - Accessing JavaScript Properties:
        - The syntax for accessing the property of an object is:
            - objectName.property      // person.age
            or
            - objectName["property"]   // person["age"]
            or
            - objectName[expression]   // x = "age"; person[x]
        - The expression must evaluate to a property name.
##############################################
- JavaScript supports different kinds of loops:
    - for - loops through a block of code a number of times
    - for/in - loops through the properties of an object
    - for/of - loops through the values of an iterable object
    - while - loops through a block of code while a specified condition is true
    - do/while - also loops through a block of code while a specified condition is true
###################################################
- JavaScript Array Iteration
    - Array forEach()
        - The forEach() method calls a function for each element in an array.
        - The forEach() method is not executed for empty elements.
        - Syntax: array.forEach(function(currentValue, index, arr), thisValue)
        - Parameters:
            function(): Required. A function to run for each array element.
            currentValue: Required.The value of the current element.
            index: Optional.The index of the current element.
            arr: Optional. The array of the current element.
            thisValue: Optional. Default undefined. A value passed to the function as its this value.
        - Return Value: undefined
        - example 1:
            let sum = 0;
            const numbers = [65, 44, 12, 4];
            numbers.forEach(myFunction);

            function myFunction(item) {
                sum += item;
            }
        - example 2:
            const numbers = [65, 44, 12, 4];
            numbers.forEach(myFunction)

            function myFunction(item, index, arr) {
                arr[index] = item * 10;
            }
    - Array map():
        - The map() method creates a new array by performing a function on each array element.
        - The map() method does not execute the function for array elements without values.
        - The map() method does not change the original array.
        - Example:
            const numbers1 = [45, 4, 9, 16, 25];
            const numbers2 = numbers1.map(myFunction);

            function myFunction(value, index, array) {
                return value * 2;
            }
        - Note that the function takes 3 arguments:
            - The item value
            - The item index
            - The array itself
    - Array filter():
        - The filter() method creates a new array with array elements that pass a test.
        - This example creates a new array from elements with a value larger than 18:
        - Example:
            const numbers = [45, 4, 9, 16, 25];
            const over18 = numbers.filter(myFunction);

            function myFunction(value, index, array) {
                return value > 18;
            }
        - Note that the function takes 3 arguments:
            - The item value
            - The item index
            - The array itself
    - Array reduce():
        - The reduce() method runs a function on each array element to produce (reduce it to) a single value.
        - The reduce() method works from left-to-right in the array. See also reduceRight().
        - The reduce() method does not reduce the original array.
        - This example finds the sum of all numbers in an array:
        - Example
            const numbers = [45, 4, 9, 16, 25];
            let sum = numbers.reduce(myFunction);

            function myFunction(total, value, index, array) {
                return total + value;
            }
        - Note that the function takes 4 arguments:
            - The total (the initial value / previously returned value)
            - The item value
            - The item index
            - The array itself
    - Array every():
        - The every() method checks if all array values pass a test.
        - This example checks if all array values are larger than 18:
        - Example
            const numbers = [45, 4, 9, 16, 25];
            let allOver18 = numbers.every(myFunction);

            function myFunction(value, index, array) {
                return value > 18;
            }
            -> result: All over 18 is false
        - Note that the function takes 3 arguments:
            - The item value
            - The item index
            - The array itself
    - Array some():
        - The some() method checks if some array values pass a test.
        - This example checks if some array values are larger than 18:
        - Example
            const numbers = [45, 4, 9, 16, 25];
            let someOver18 = numbers.some(myFunction);

            function myFunction(value, index, array) {
                return value > 18;
            }
            -> result: Some over 18 is true
        - Note that the function takes 3 arguments:
            - The item value
            - The item index
            - The array itself
    - Array Spread (...):
        - The ... operator expands an iterable (like an array) into more elements:
        - Example:
            const q1 = ["Jan", "Feb", "Mar"];
            const q2 = ["Apr", "May", "Jun"];
            const q3 = ["Jul", "Aug", "Sep"];
            const q4 = ["Oct", "Nov", "May"];

            const year = [...q1, ...q2, ...q3, ...q4];
##############################################
- What is this?
        - In JavaScript, the this keyword refers to an object.
        - Which object depends on how this is being invoked (used or called).
        - The this keyword refers to different objects depending on how it is used:
            - In an object method, this refers to the object.
            - Alone, this refers to the global object.
            - In a function, this refers to the global object.
            - In a function, in strict mode, this is undefined.
            - In an event, this refers to the element that received the event.
            - Methods like call(), apply(), and bind() can refer this to any object.
            - this is not a variable. It is a keyword. You cannot change the value of this.
################################################
#####################################################
Object.defineProperties()
    - The Object.defineProperties() static method defines new or modifies existing properties directly on an object, returning the object.
        const object1 = {};
        Object.defineProperties(object1, {
        property1: {
            value: 42,
            writable: true,
        },
        property2: {},
        });
        console.log(object1.property1);
        // Expected output: 42
    - Syntax:
        Object.defineProperties(obj, props)
        - Parameters:
            - obj
                - The object on which to define or modify properties.
            - props:
                - An object whose keys represent the names of properties to be defined or
                  modified and whose values are objects describing those properties.
                  Each value in props must be either a data descriptor or an accessor descriptor;
                  it cannot be both (see Object.defineProperty() for more details).
                - Data descriptors and accessor descriptors may optionally contain the following keys:
                    - configurable: 
                        - true if and only if the type of this property descriptor may be changed
                          and if the property may be deleted from the corresponding object. Defaults to false.
                    - enumerable:
                        - true if and only if this property shows up during enumeration
                          of the properties on the corresponding object. Defaults to false.
                - A data descriptor also has the following optional keys:
                    - value
                        - The value associated with the property. 
                          Can be any valid JavaScript value (number, object, function, etc.). 
                          Defaults to undefined.
                    - writable
                        - true if and only if the value associated with the property may be changed
                          with an assignment operator. Defaults to false.
                - An accessor descriptor also has the following optional keys:
                    - get
                        - A function which serves as a getter for the property, or undefined if there is no getter.
                          The function's return value will be used as the value of the property. 
                          Defaults to undefined.

                    - set
                        - A function which serves as a setter for the property, or undefined if there is no setter.
                          The function will receive as its only argument the new value being assigned to the property. 
                          Defaults to undefined.
                - If a descriptor has neither of value, writable, get and set keys, it is treated as a data descriptor.
                  If a descriptor has both value or writable and get or set keys, an exception is thrown.
                - Return value:
                    - The object that was passed to the function.
                        const obj = {};
                        Object.defineProperties(obj, {
                            property1: {
                                value: true,
                                writable: true,
                            },
                            property2: {
                                value: "Hello",
                                writable: false,
                            },
                            // etc. etc.
                        });
#####################################################
Object.defineProperty()
    - The Object.defineProperty() static method defines a new property directly on an object, 
      or modifies an existing property on an object, and returns the object.
        const object1 = {};
        Object.defineProperty(object1, 'property1', {
            value: 42,
            writable: false,
        });
        object1.property1 = 77;
        // Throws an error in strict mode
        console.log(object1.property1);
        // Expected output: 42
    - Syntax:
        Object.defineProperty(obj, prop, descriptor)
        - Parameters:
            - obj
                The object on which to define the property.
            - prop
                A string or Symbol specifying the key of the property to be defined or modified.
            - descriptor
                The descriptor for the property being defined or modified.
    - Return value:
        - The object that was passed to the function, with the specified property added or modified.
    - Description:
        - Object.defineProperty() allows a precise addition to or modification of a property on an object.
          Normal property addition through assignment creates properties which show up during
          property enumeration (for...in, Object.keys(), etc.), whose values may be changed and which may be deleted.
          This method allows these extra details to be changed from their defaults. 
          By default, properties added using Object.defineProperty() are not writable, 
          not enumerable, and not configurable. In addition, Object.defineProperty() uses the [[DefineOwnProperty]] internal method,
          instead of [[Set]], so it does not invoke setters, even when the property is already present.
        - Property descriptors present in objects come in two main flavors: 
          data descriptors and accessor descriptors. A data descriptor is a property with a value that may or may not be writable.
          An accessor descriptor is a property described by a getter-setter pair of functions. 
          A descriptor must be one of these two flavors; it cannot be both.
        - Both data and accessor descriptors are objects. They share the following optional keys
          (please note: the defaults mentioned here are in the case of defining properties using Object.defineProperty()):
            - configurable:
                - the type of this property cannot be changed between data property and accessor property, and
                - the property may not be deleted, and
                - other attributes of its descriptor cannot be changed (however, if it's a data descriptor with writable: true,
                  the value can be changed, and writable can be changed to false).
                - Defaults to false.
            - enumerable:
                - true if and only if this property shows up during enumeration of the properties on the corresponding object. 
                - Defaults to false.
        - A data descriptor also has the following optional keys:
            - value
                - The value associated with the property. Can be any valid JavaScript value (number, object, function, etc.). 
                  Defaults to undefined.
            - writable
                - true if the value associated with the property may be changed with an assignment operator. 
                  Defaults to false.
        - An accessor descriptor also has the following optional keys:
            - get
                - A function which serves as a getter for the property, or undefined if there is no getter.
                  When the property is accessed, this function is called without arguments and with this set
                  to the object through which the property is accessed (this may not be the object on which the property is defined due to inheritance).
                  The return value will be used as the value of the property. 
                - Defaults to undefined.
            - set
                - A function which serves as a setter for the property, or undefined if there is no setter.
                  When the property is assigned, this function is called with one argument (the value being assigned to the property)
                  and with this set to the object through which the property is assigned. 
                - Defaults to undefined.
        - If a descriptor doesn't have any of the value, writable, get, and set keys, it is treated as a data descriptor. 
          If a descriptor has both [value or writable] and [get or set] keys, an exception is thrown.
        - These attributes are not necessarily the descriptor's own properties. 
          Inherited properties will be considered as well. In order to ensure these defaults are
          preserved, you might freeze existing objects in the descriptor object's prototype chain upfront,
          specify all options explicitly, or create a null-prototype object.
        - Creating a property
            - example:
                const o = {}; // Creates a new object

                // Example of an object property added
                // with defineProperty with a data property descriptor
                Object.defineProperty(o, "a", {
                    value: 37,
                    writable: true,
                    enumerable: true,
                    configurable: true,
                });
                // 'a' property exists in the o object and its value is 37
        - Modifying a property
            - Writable attribute:
                - When the writable property attribute is false, the property is said to be "non-writable". 
                  It cannot be reassigned. Trying to write to a non-writable property doesn't change it
                  and results in an error in strict mode.
                - example:
                    const o = {}; // Creates a new object
                    Object.defineProperty(o, "a", {
                        value: 37,
                        writable: false,
                    });
                    console.log(o.a); // 37
                    o.a = 25; // No error thrown
                    // (it would throw in strict mode,
                    // even if the value had been the same)
                    console.log(o.a); // 37; the assignment didn't work
                    // strict mode
                    (() => {
                        "use strict";
                        const o = {};
                        Object.defineProperty(o, "b", {
                            value: 2,
                            writable: false,
                        });
                        o.b = 3; // throws TypeError: "b" is read-only
                        return o.b; // returns 2 without the line above
                    })();
#################################################
JavaScript Object Prototypes
    - All JavaScript objects inherit properties and methods from a prototype.
    - Prototype Inheritance
        - All JavaScript objects inherit properties and methods from a prototype:
            - Date objects inherit from Date.prototype
            - Array objects inherit from Array.prototype
            - Person objects inherit from Person.prototype     
        - The Object.prototype is on the top of the prototype inheritance chain:
        - Date objects, Array objects, and Person objects inherit from Object.prototype.  
    - Adding Properties and Methods to Objects
        - Sometimes you want to add new properties (or methods) to all existing objects of a given type.
        - Sometimes you want to add new properties (or methods) to an object constructor. 
    - Using the prototype Property:
        - The JavaScript prototype property allows you to add new properties to object constructors:
            function Person(first, last, age, eyecolor) {
                this.firstName = first;
                this.lastName = last;
                this.age = age;
                this.eyeColor = eyecolor;
            }
            Person.prototype.nationality = "English";
        - The JavaScript prototype property also allows you to add new methods to objects constructors:
            function Person(first, last, age, eyecolor) {
                this.firstName = first;
                this.lastName = last;
                this.age = age;
                this.eyeColor = eyecolor;
            }
            Person.prototype.name = function() {
                return this.firstName + " " + this.lastName;
            };
    - Only modify your own prototypes. Never modify the prototypes of standard JavaScript objects.
####################################################
JavaScript Modules
    - JavaScript modules allow you to break up your code into separate files.
    - This makes it easier to maintain a code-base.
    - Modules are imported from external files with the import statement.
    - Modules also rely on type="module" in the <script> tag.
        <script type="module">
            import message from "./message.js";
        </script>
    - Export:
        - Modules with functions or variables can be stored in any external file.
        - There are two types of exports: Named Exports and Default Exports.

        - Named Exports:
            - Let us create a file named person.js, and fill it with the things we want to export.
            - You can create named exports two ways. In-line individually, or all at once at the bottom.
            - In-line individually:
                - person.js:
                    export const name = "Jesse";
                    export const age = 40;
            - All at once at the bottom:
                - person.js:
                    const name = "Jesse";
                    const age = 40;
                    export {name, age};
        - Default Exports:
            - Let us create another file, named message.js, and use it for demonstrating default export.
            - You can only have one default export in a file.
                - message.js
                    const message = () => {
                        const name = "Jesse";
                        const age = 40;
                        return name + ' is ' + age + 'years old.';
                    };
                    export default message;
    - Import:
        - You can import modules into a file in two ways, based on if they are named exports or default exports.
        - Named exports are constructed using curly braces. Default exports are not.
        - Import from named exports:
            - Import named exports from the file person.js:
                import { name, age } from "./person.js";
        - Import from default exports:
            - Import a default export from the file message.js:
                import message from "./message.js";
    - Modules only work with the HTTP(s) protocol.
    - A web-page opened via the file:// protocol cannot use import / export.
#######################################
JavaScript Function call()
    - Method Reuse:
        - With the call() method, you can write a method that can be used on different objects.
    - All Functions are Methods:
        - In JavaScript all functions are object methods.
        - If a function is not a method of a JavaScript object, it is a function of the global object (see previous chapter).
        - The example below creates an object with 3 properties, firstName, lastName, fullName.
        - Example
            const person = {
                firstName:"John",
                lastName: "Doe",
                fullName: function () {
                    return this.firstName + " " + this.lastName;
                }
            }
            // This will return "John Doe":
            person.fullName();
        - In the example above, this refers to the person object.
        - this.firstName means the firstName property of this.
        - Same as: this.firstName means the firstName property of person.
    - The JavaScript call() Method:
        - The call() method is a predefined JavaScript method.
        - It can be used to invoke (call) a method with an owner object as an argument (parameter).
        - With call(), an object can use a method belonging to another object.
        - This example calls the fullName method of person, using it on person1:
            const person = {
                fullName: function() {
                    return this.firstName + " " + this.lastName;
                }
            }
            const person1 = {
                firstName:"John",
                lastName: "Doe"
            }
            const person2 = {
                firstName:"Mary",
                lastName: "Doe"
            }
            // This will return "John Doe":
            person.fullName.call(person1);
        - This example calls the fullName method of person, using it on person2:
            const person = {
                fullName: function() {
                    return this.firstName + " " + this.lastName;
                }
            }
            const person1 = {
                firstName:"John",
                lastName: "Doe"
            }
            const person2 = {
                firstName:"Mary",
                lastName: "Doe"
            }
            // This will return "Mary Doe"
            person.fullName.call(person2);
        - The call() Method with Arguments:
            - The call() method can accept arguments:
                const person = {
                    fullName: function(city, country) {
                        return this.firstName + " " + this.lastName + "," + city + "," + country;
                    }
                }
                const person1 = {
                    firstName:"John",
                    lastName: "Doe"
                }
                person.fullName.call(person1, "Oslo", "Norway");
#############################################
JavaScript Function apply()
    - Method Reuse
        - With the apply() method, you can write a method that can be used on different objects.
    - The JavaScript apply() Method
        - The apply() method is similar to the call() method (previous chapter).
        - In this example the fullName method of person is applied on person1:
            const person = {
                fullName: function() {
                    return this.firstName + " " + this.lastName;
                }
            }
            const person1 = {
                firstName: "Mary",
                lastName: "Doe"
            }
            // This will return "Mary Doe":
            person.fullName.apply(person1);
    - The Difference Between call() and apply()
        - The call() method takes arguments separately.
        - The apply() method takes arguments as an array.
        - The apply() method is very handy if you want to use an array instead of an argument list.
    - The apply() Method with Arguments:
        - The apply() method accepts arguments in an array:
            const person = {
                fullName: function(city, country) {
                    return this.firstName + " " + this.lastName + "," + city + "," + country;
                }
            }
            const person1 = {
                firstName:"John",
                lastName: "Doe"
            }
            person.fullName.apply(person1, ["Oslo", "Norway"]);
        - Compared with the call() method:
            const person = {
                fullName: function(city, country) {
                    return this.firstName + " " + this.lastName + "," + city + "," + country;
                }
            }
            const person1 = {
                firstName:"John",
                lastName: "Doe"
            }
            person.fullName.call(person1, "Oslo", "Norway");
######################################
JavaScript Function bind()
    - Function Borrowing
        - With the bind() method, an object can borrow a method from another object.
        - The example below creates 2 objects (person and member).
        - The member object borrows the fullname method from the person object:
            const person = {
                firstName:"John",
                lastName: "Doe",
                fullName: function () {
                    return this.firstName + " " + this.lastName;
                }
            }
            const member = {
                firstName:"Hege",
                lastName: "Nilsen",
            }
            let fullName = person.fullName.bind(member);
    - Preserving this:
        - Sometimes the bind() method has to be used to prevent losing this.
        - In the following example, the person object has a display method. In the display method, this refers to the person object:
            const person = {
                firstName:"John",
                lastName: "Doe",
                display: function () {
                    let x = document.getElementById("demo");
                    x.innerHTML = this.firstName + " " + this.lastName;
                }
            }
            person.display();
        - When a function is used as a callback, this is lost.
        - This example will try to display the person name after 3 seconds, but it will display undefined instead:
            const person = {
                firstName:"John",
                lastName: "Doe",
                display: function () {
                    let x = document.getElementById("demo");
                    x.innerHTML = this.firstName + " " + this.lastName;
                }
            }
            setTimeout(person.display, 3000);
            -> result: undefined undefined
        - The bind() method solves this problem.
        - In the following example, the bind() method is used to bind person.display to person.
        - This example will display the person name after 3 seconds:
            const person = {
                firstName:"John",
                lastName: "Doe",
                display: function () {
                    let x = document.getElementById("demo");
                    x.innerHTML = this.firstName + " " + this.lastName;
                }
            }

            let display = person.display.bind(person);
            setTimeout(display, 3000);
######################################
The JavaScript this Keyword:
    -Example
        const person = {
            firstName: "John",
            lastName : "Doe",
            id       : 5566,
            fullName : function() {
                return this.firstName + " " + this.lastName;
            }
        };
    - What is this?
        - In JavaScript, the this keyword refers to an object.
        - Which object depends on how this is being invoked (used or called).
        - The this keyword refers to different objects depending on how it is used:
            - In an object method, this refers to the object.
            - Alone, this refers to the global object.
            - In a function, this refers to the global object.
            - In a function, in strict mode, this is undefined.
            - In an event, this refers to the element that received the event.
            - Methods like call(), apply(), and bind() can refer this to any object.
            - this is not a variable. It is a keyword. You cannot change the value of this.
    - this in a Method:
        - When used in an object method, this refers to the object.
        - In the example on top of this page, this refers to the person object.
        - Because the fullName method is a method of the person object.
    - this Alone:
        - When used alone, this refers to the global object.
        - Because this is running in the global scope.
        - In a browser window the global object is [object Window]:
            let x = this;
        - In strict mode, when used alone, this also refers to the global object:
            "use strict";
            let x = this;
    - this in a Function (Default):
        - In a function, the global object is the default binding for this.
        - In a browser window the global object is [object Window]:
            function myFunction() {
                return this;
            }
    - this in a Function (Strict):
        - JavaScript strict mode does not allow default binding.
        - So, when used in a function, in strict mode, this is undefined.
    - this in Event Handlers:
        - In HTML event handlers, this refers to the HTML element that received the event:
            ex: <button onclick="this.style.display='none'">Click to Remove Me!</button>
    - Object Method Binding:
        - In these examples, this is the person object:
            const person = {
                firstName  : "John",
                lastName   : "Doe",
                id         : 5566,
                myFunction : function() {
                    return this;
                }
            };

            const person = {
                firstName: "John",
                lastName : "Doe",
                id       : 5566,
                fullName : function() {
                    return this.firstName + " " + this.lastName;
                }
            };
            i.e. this.firstName is the firstName property of this (the person object).
    - Explicit Function Binding:
        - The call() and apply() methods are predefined JavaScript methods.
        - They can both be used to call an object method with another object as argument.
        - The example below calls person1.fullName with person2 as an argument,
          this refers to person2, even if fullName is a method of person1:
            const person1 = {
                fullName: function() {
                    return this.firstName + " " + this.lastName;
                }
            }
            const person2 = {
                firstName:"John",
                lastName: "Doe",
            }
            // Return "John Doe"; object person2 call method fullName
            person1.fullName.call(person2);
    - Function Borrowing:
        - With the bind() method, an object can borrow a method from another object.
        - This example creates 2 objects (person and member).
        - The member object borrows the fullname method from the person object:
            const person = {
                firstName:"John",
                lastName: "Doe",
                fullName: function () {
                    return this.firstName + " " + this.lastName;
                }
            }
            const member = {
                firstName:"Hege",
                lastName: "Nilsen",
            }
            let fullName = person.fullName.bind(member);
####################################
ES6 Arrow Functions:
    - Block body thì => return keyword cần có
    - Concise(dạng ngắn gọn) body thì => return keyword là implied và không cần thiết
        Example A: Normal Function
        const sayHi = function(name) {
            return name
        }

        Example B: Arrow Function with Explicit Return
        // Multi-line
        const sayHi = (name) => {
            return name
        }

        // Single-line
        const sayHi = (name) => { return name }

        Example C: Arrow Function with Implicit Return
        // Single-line
        const sayHi = (name) => name

        // Multi-line
        const sayHi = (name) => (
            name
        )
    - Returning Objects:
        - const me = () => { name: "samantha" };
            me(); // undefined 😱
        - const me = () => ({ name: "samantha" });
            me(); // { name: "samantha" }
##################################
ExpressJS

    - ví dụ:
        import express from "express";
        import mongoose from "mongoose";
        import dotenv from "dotenv";
        import userRoute from "./routes/user.route.js";
        import gigRoute from "./routes/gig.route.js";
        import orderRoute from "./routes/order.route.js";
        import conversationRoute from "./routes/conversation.route.js";
        import messageRoute from "./routes/message.route.js";
        import reviewRoute from "./routes/review.route.js";
        import authRoute from "./routes/auth.route.js";
        import uploadRoute from "./routes/upload.route.js";
        import cookieParser from "cookie-parser";
        import cors from "cors";

        const app = express();
        mongoose.set("strictQuery", true);
        dotenv.config();
        app.use(express.urlencoded({
            extended: true
        }))

        const connect = async () => {
            try {
                await mongoose.connect(process.env.MONGO);
                console.log("Connected to mongoDB!");
            } catch (error) {
                console.log(error.message);
            }
        };

        // cần sử dụng thư viện này vì nếu ta gọi từ ứng bên client chạy react đến api, sẽ gặp lỗi 
        // cors policy vì chúng ta đang cố truy cập đến api từ một nơi khác. thư viện này cho phép ta
        // nói với ứng dụng là cho phép domain này truy cập vào api của chúng ta
        app.use(cors({ origin: "http://localhost:5173", credentials: true }));

        app.use(express.json());
        app.use(cookieParser());

        app.use("/api/auth", authRoute);
        app.use("/api/users", userRoute);
        app.use("/api/gigs", gigRoute);
        app.use("/api/orders", orderRoute);
        app.use("/api/conversations", conversationRoute);
        app.use("/api/messages", messageRoute);
        app.use("/api/reviews", reviewRoute);
        app.use("/api/upload", uploadRoute);

        app.use((err, req, res, next) => {
            const errorStatus = err.status || 500;
            const errorMessage = err.message || "Something went wrong";
            return res.status(errorStatus).send(errorMessage);
        });
        app.listen(8000, () => {
            connect();
            console.log("Backend server is running");
        });
- Công dụng của hàm app.use:
    - Đăng ký middleware: Hàm app.use được sử dụng để đăng ký middleware với ứng dụng Express. 
      Middleware là các hàm được sử dụng để xử lý các yêu cầu HTTP trước khi chúng được chuyển đến các tuyến đường.
    - Xử lý các yêu cầu: Middleware có thể được sử dụng để thực hiện các tác vụ như:
        - Xác thực và ủy quyền
        - Phân tích dữ liệu yêu cầu
        - Ghi nhật ký
        - Xử lý lỗi
    - Cấu hình linh hoạt: Hàm app.use cho phép bạn cấu hình ứng dụng Express theo cách linh hoạt. 
      Bạn có thể đăng ký middleware cho các tuyến đường cụ thể hoặc cho toàn bộ ứng dụng.

- Thứ tự thực hiện middleware và số lượng đối số trong hàm callback
    - Thứ tự thực hiện middleware:
        - Middleware được thực thi theo thứ tự được khai báo trong mã.
        - Middleware được đặt trước sẽ được thực thi trước, sau đó đến các middleware được đặt sau.
- Số lượng đối số trong hàm callback:
    - Số lượng đối số trong hàm callback của middleware không ảnh hưởng đến thứ tự thực hiện.
    - Nó chỉ ảnh hưởng đến chức năng của middleware.
- Ví dụ:
    app.use((req, res, next) => {
    console.log('Middleware 1');
    next();
    });

    app.use((req, res, next) => {
    console.log('Middleware 2');
    next();
    });

    app.get('/', (req, res) => {
    res.send('Hello World!');
    });

    app.listen(3000);
- Trong ví dụ này, cả hai middleware đều có 3 đối số: req, res và next.
- Tuy nhiên, middleware 1 sẽ được thực thi trước middleware 2 vì nó được khai báo trước.

- Bảng sau đây tóm tắt số lượng đối số phổ biến trong hàm callback của middleware và chức năng của chúng:

    Số lượng đối    số	Chức năng
    4	            Middleware xử lý lỗi
    3	            Middleware thông thường
    2	            Middleware chỉ xử lý request và response

- Lưu ý:
    - Bạn có thể sử dụng bất kỳ số lượng đối số nào trong hàm callback của middleware.
    - Tuy nhiên, 3 đối số là phổ biến nhất.
    - Middleware xử lý lỗi phải có 4 đối số.

Kết luận:

    - Thứ tự thực hiện middleware được xác định bởi thứ tự khai báo trong mã, không phải bởi số lượng đối số trong hàm callback.
      Số lượng đối số chỉ ảnh hưởng đến chức năng của middleware.

- Hàm app.listen(3000); được đặt ở cuối cùng để đảm bảo rằng tất cả các middleware và tuyến đường đã được định nghĩa trước
  khi máy chủ Express bắt đầu lắng nghe các yêu cầu.
#################################
- Hàm next
    Hàm next được sử dụng trong middleware để chuyển tiếp yêu cầu đến middleware tiếp theo trong chuỗi.
    Nó hoạt động như một cờ hiệu để cho biết middleware hiện tại đã hoàn tất việc xử lý yêu cầu và middleware tiếp theo có thể bắt đầu.

- Cách thức hoạt động:
    - Khi một middleware được gọi, nó có thể thực hiện một số thao tác với yêu cầu và phản hồi.
    - Nếu middleware muốn chuyển tiếp yêu cầu đến middleware tiếp theo, nó cần gọi hàm next.
    - Nếu middleware không gọi next, yêu cầu sẽ không được chuyển tiếp và sẽ dừng lại tại middleware hiện tại.
- Ví dụ:
    app.use((req, res, next) => {
    console.log('Middleware 1');
    next();
    });

    app.use((req, res, next) => {
    console.log('Middleware 2');
    next();
    });

    app.get('/', (req, res) => {
    res.send('Hello World!');
    });

    app.listen(3000);

    - Trong ví dụ này, khi một yêu cầu được gửi đến /, nó sẽ được xử lý bởi hai middleware trước khi đến được tuyến đường. 
    - Mỗi middleware sẽ ghi nhật ký một thông báo vào bảng điều khiển và sau đó gọi next để chuyển tiếp yêu cầu đến middleware tiếp theo.

- Lưu ý:
    - Hàm next không bắt buộc phải được gọi trong middleware.
    - Nếu bạn không gọi next, yêu cầu sẽ dừng lại tại middleware hiện tại.
    - Bạn có thể sử dụng next để chuyển tiếp yêu cầu đến một middleware cụ thể.

- Công dụng khác của next:
    - Bỏ qua các middleware: Bạn có thể sử dụng next('route') để bỏ qua các middleware còn lại và chuyển tiếp yêu cầu đến một tuyến đường cụ thể.
    - Gửi lỗi: Bạn có thể sử dụng next(new Error('Error message')) để gửi một lỗi đến middleware xử lý lỗi.
- Kết luận:
    - Hàm next là một phần quan trọng trong việc xử lý các yêu cầu trong ứng dụng Express. 
    - Nó cho phép bạn kiểm soát luồng yêu cầu và chuyển tiếp yêu cầu đến các middleware khác nhau.
################################################
- Mình có một website, mình muốn website đó được hiển thị lên tìm kiếm của google thì mình cần thiết lập những gì?
    Để website của bạn được hiển thị lên kết quả tìm kiếm của Google, bạn cần chú ý đến những yếu tố sau:
    1. Search Engine Optimization (SEO): Tối ưu hóa website cho công cụ tìm kiếm là bước không thể bỏ qua, gồm có:
        - Tối ưu hóa nội dung: Sử dụng các từ khóa liên quan đến ngành nghề hoặc chủ đề mà trang web của bạn tập trung vào.
        - Meta tags: Cung cấp meta descriptions và meta titles có chứa từ khóa.
        - Tối ưu hóa hình ảnh: Sử dụng alt tags cho hình ảnh và tối ưu hóa kích thước của ảnh để tải trang nhanh hơn.
        - Nội dung chất lượng: Đảm bảo bạn cung cấp thông tin có giá trị, độc đáo và thường xuyên cập nhật.
    2. Mobile-friendly: Đảm bảo rằng website của bạn tương thích với thiết bị di động, vì Google chuộng các trang web thân thiện với mobile.
    3. Page Speed: Tăng tốc độ tải trang của bạn vì tốc độ tải trang là một yếu tố xếp hạng quan trọng của Google.
    4. Backlinks: Xây dựng backlinks chất lượng từ các trang web uy tín, điều này càng chứng minh cho Google rằng trang web của bạn có giá trị.
    5. Google Search Console: Đăng ký sử dụng Google Search Console để theo dõi cách Google xem và xếp hạng trang web của bạn.
    6. Sitemaps và robots.txt: Tạo và gửi sitemap cho Google để giúp Google tìm và lập chỉ mục các trang của bạn nhanh chóng hơn, và sử dụng file robots.txt
       để hướng dẫn bots của công cụ tìm kiếm cách tiếp cận trang web của bạn.
    7. Social Media và Marketing Content: Sử dụng mạng xã hội và content marketing để tạo traffic tự nhiên về trang web của bạn.
    8. Local SEO: Nếu bạn có doanh nghiệp địa phương, hãy đảm bảo rằng bạn có danh sách trên Google My Business.
    9. Rich Snippets: Sử dụng Schema markup để giúp Google hiểu nội dung của trang bạn tốt hơn và có thể hiển thị nội dung nổi bật
       của bạn thành các rich snippets trên trang kết quả tìm kiếm.
    10. Security: Sử dụng HTTPS để bảo mật thông tin của người dùng và tăng cơ hội được xếp hạng cao hơn trong kết quả tìm kiếm của Google.
    Hiểu biết sâu sắc và áp dụng đúng cách những yếu tố trên sẽ giúp website của bạn tối ưu hóa được hiệu suất trên công cụ tìm kiếm và gia tăng khả năng hiển thị.

- Bạn có thể hướng dẫn mình về bước 5 và 6 không

    ### Bước 5: Sử dụng Google Search Console

        Google Search Console (GSC) là một dịch vụ miễn phí của Google giúp bạn theo dõi và duy trì sự hiện diện của website trong kết quả tìm kiếm Google. Đây là cách bạn sử dụng GSC:

        1. Đăng ký: Truy cập Google Search Console và sử dụng tài khoản Google để đăng ký.
        2. Xác minh website: Bạn cần xác minh sở hữu trang web của mình. Có nhiều cách để làm điều này, ví dụ như tải lên một file HTML vào root directory của website, hoặc thêm một thẻ meta vào homepage.
        3. Gửi Sitemap: Sitemap là một file XML chứa danh sách các URLs trong site của bạn và có thể giúp Google dễ dàng tìm và lập chỉ mục trang web. Tạo sitemap và gửi nó thông qua GSC.
        4. Giám sát: Theo dõi các chỉ số hiệu suất, như số lần click, số lần hiển thị, vị trí trung bình của các từ khóa và nhiều thứ khác.
        5. Kiểm tra lỗi: Sử dụng GSC để kiểm tra xem có lỗi lập chỉ mục hay lỗi mobile usability nào không và sửa chúng.
        6. Tối ưu hóa: Sử dụng thông tin từ GSC để tối ưu hóa từ khóa và cải thiện chiến lược nội dung của bạn.

    ### Bước 6: Tạo và sử dụng Sitemaps và robots.txt

        1. Sitemaps:
            - Tạo sitemap dạng XML cho website của bạn, công cụ tạo sitemap miễn phí trực tuyến có thể giúp bạn nếu website chưa có sitemap.
            - Một sitemap thông thường nên cập nhật định kỳ và gồm có các trang quan trọng của bạn.
            - Gửi sitemap đến Google thông qua Google Search Console để giúp Google lập chỉ mục trang web của bạn nhanh chóng và dễ dàng hơn.

        2. robots.txt:
            - File robots.txt là một file văn bản được đặt ở root của domain để hướng dẫn các web crawler xem nên và không nên lập chỉ mục phần nào của website.
            - Bạn có thể sử dụng file này để loại trừ các trang không muốn công cụ tìm kiếm lập chỉ mục, nhưng hãy cẩn thận vì sai sót có thể ngăn cản Google lập chỉ mục các trang quan trọng.
            - Cú pháp của robots.txt là khá đơn giản, 
                - ví dụ:
                    User-agent: *
                    Disallow: /folder/
                    Allow: /folder/myfile.html
                - giải thích:
                    - "User-agent: *" nghĩa là các hướng dẫn sau áp dụng cho tất cả các web crawlers.
                    - "Disallow: /folder/" ngăn chặn các crawlers truy cập vào thư mục chứa đường dẫn "/folder/".
                    - "Allow: /folder/myfile.html" cho phép truy cập vào file cụ thể "myfile.html" nằm trong thư mục bị cấm kia.
        Kiểm tra cường độ thường xuyên để đảm bảo rằng cả robots.txt và sitemap vẫn phản ánh chính xác cấu trúc và nội dung của trang web bạn.
        Nhớ là bạn phải thường xuyên theo dõi và điều chỉnh để phản ánh đúng nhất nội dung và cấu trúc website hiện tại của bạn nhé!
################################################
Hãy giúp tôi hiểu rõ về emit event trong nodejs nhé?

    Event emitting trong Node.js là một phần của mô hình Event-Driven Architecture, nơi mà các đối tượng (thường được gọi là emitters)
    phát ra các sự kiện hoặc tín hiệu về việc một số trạng thái hoặc hành động đã xảy ra. Các đối tượng khác, được gọi là listeners hoặc handlers,
    sau đó sẽ phản hồi lại với các sự kiện đó.

    Dưới đây là một số điểm cơ bản về emit event trong Node.js:

        1. EventEmitter Class: Node.js cung cấp một module events bao gồm EventEmitter class, đây là nền tảng cho việc phát và lắng nghe các sự kiện.
        const EventEmitter = require('events');
        class MyEmitter extends EventEmitter {}

        2. Tạo Emitter: Bạn tạo một emitter bằng cách khởi tạo một instance của class EventEmitter hoặc một subclass mở rộng từ nó.
        const myEmitter = new MyEmitter();

        3. Emitting Events: Bạn phát một sự kiện bằng phương thức .emit(), và đặt tên cho sự kiện. Bạn cũng có thể truyền một số dữ liệu làm đối số cho sự kiện đó.
        // Phát sự kiện 'event'
        myEmitter.emit('event');
        // Phát sự kiện 'event' với đối số
        myEmitter.emit('event', { a: 1, b: 2 });

        4. Listening for Events: Để xử lý một sự kiện, bạn cần đăng ký một listener cho sự kiện đó sử dụng phương thức .on() hoặc .addListener().
        // Đăng ký một listener cho 'event'
        myEmitter.on('event', (data) => {
        console.log('An event occurred!', data);
        });

        5. Emitter với Nhiều Listeners: Bạn có thể có nhiều listeners cho cùng một sự kiện và chúng sẽ được thực thi theo thứ tự mà bạn đăng ký.
        myEmitter.on('event', function firstListener() {
        console.log('Helloooo! first listener');
        });
        myEmitter.on('event', function secondListener(arg1, arg2) {
        console.log(event with parameters ${arg1}, ${arg2} in second listener);
        });
        myEmitter.emit('event', 1, 2);

        6. Ứng Dụng của Event Emitter: Trong Node.js, emit event được sử dụng rộng rãi - từ việc xử lý HTTP requests trong express đến việc đọc dữ liệu từ streams.

        7. Lắng Nghe Sự Kiện Một Lần: Sử dụng .once() thay vì .on() để đăng ký một listener chạy một lần duy nhất.

        8. Xóa Listeners: Bạn có thể gỡ bỏ các listeners khỏi một emitter sử dụng .removeListener() hoặc .off().
        const callback = (data) => {
        console.log('An event occurred with data:', data);
        };
        myEmitter.on('event', callback);
        // Sau một thủ tục nào đó
        myEmitter.removeListener('event', callback);

        9. Giới Hạn về Số Listeners: Mặc định, một emitter có thể có tối đa 10 listeners đăng ký cho mỗi sự kiện. Bạn có thể thay đổi giới hạn này sử dụng .setMaxListeners().

        10. Error Events: Emitter cũng có thể phát ra các sự kiện error. Nếu có lỗi xảy ra và không có listener nào cho sự kiện error, ứng dụng sẽ crash và in ra một stack trace.

        Như bạn thấy, emit và listen cho events trong Node.js là khá đơn giản nhưng mạnh mẽ, cho phép bạn thiết kế ứng dụng linh hoạt và dễ mở rộng.
############################################################
Decorator pattern là gì, áp dụng với nodejs như thế nào? Hãy giúp tôi giải thích là lấy ví dụ cụ thể chi tiết được không
    Decorator Pattern là một design pattern mà cho phép bạn "trang trí" hoặc "gắn thêm" các chức năng cho các objects mà không
    cần sửa đổi code của class gốc (base class). Đây là một kỹ thuật phổ biến để mở rộng chức năng của các class trong
    lập trình theo hướng đối tượng, và nó được sử dụng để tuân thủ nguyên tắc Open/Closed principle, một trong ngũ quy tắc
    SOLID của lập trình hướng đối tượng (OOP).

    Trong JavaScript và Node.js, Decorator Pattern thường được thực hiện thông qua việc truyền
    một đối tượng vào một hàm (đôi khi được gọi là "wrapper" hoặc "decorator function") mà sau đó
    thêm các tính năng vào đối tượng đó và trả về một đối tượng mới với chức năng đã được mở rộng.

    Hãy xem một ví dụ:
    Giả sử bạn có một lớp Car mà có một phương thức drive.
        class Car {
            drive() {
                console.log("Driving a car");
            }
        }
        const car = new Car();
        car.drive(); // Output: Driving a car
    Bây giờ, bạn muốn mở rộng chức năng của Car để nó có thể bay, nhưng không muốn sửa đổi lớp Car gốc.
    Đây là cách bạn có thể áp dụng Decorator Pattern:

        function FlyingCar(car) {
            car.fly = function() {
                console.log("Flying a car");
            };
            return car;
        }
        // Tạo một chiếc xe mới và "trang trí" nó
        const flyingCar = new FlyingCar(new Car());
        flyingCar.drive(); // Output: Driving a car
        flyingCar.fly(); // Output: Flying a car
    Trong ví dụ này, hàm FlyingCar nhận một instance của Car và thêm một phương thức mới là fly.
    Đối tượng flyingCar giờ có cả hai phương thức drive và fly mà không làm thay đổi định nghĩa gốc của lớp Car.

    Đây là một ví dụ đơn giản, nhưng trong thực tế, bạn có thể dùng Decorator để thêm nhiều lớp vỏ phức tạp
    và nhiều chức năng (như logging, caching, monitoring, v.v.) mà không làm "bẩn" các đối tượng gốc của bạn.

    Lưu ý rằng, trong lập trình JavaScript hiện đại, Decorators thường được thấy ở dạng các thư viện hoặc các nền tảng như Angular,
    với syntax mới @DecoratorName được dùng. Tuy nhiên, tính năng này đôi khi còn trong đề xuất (proposal stage) và chưa được hỗ
    trợ hoàn toàn trong Node.js mà không sử dụng Babel hoặc TypeScript để transpile code.
-------------------------------------------
Bạn có thể lấy thêm các ví dụ khác mà nó có cả interface không

    Chắc chắn rồi! Trong JavaScript, chúng ta không có khái niệm interface như trong Java hoặc TypeScript,
    nhưng chúng ta có thể mô phỏng một interface thông qua việc xác định một tập họat động của các hàm hoặc
    phương thức mà một đối tượng cần phải triển khai.

    Giả sử chúng ta muốn có một interface Vehicle với hai hàm không được triển khai: drive và clean. Trong JavaScript,
    chúng ta sẽ dùng một class trừu tượng hoặc một đối tượng với các hàm mặc định để mô tả giao diện này.

        // Định nghĩa một interface 'Vehicle'
        function Vehicle() {
        throw new Error("Không thể khởi tạo interface");
        }

        Vehicle.prototype.drive = function() {
        throw new Error("Phương thức drive cần phải được triển khai");
        };

        Vehicle.prototype.clean = function() {
        throw new Error("Phương thức clean cần phải được triển khai");
        };

    Bây giờ, chúng ta có thể tạo một class Car triển khai Vehicle interface:

        function Car() {}

        Car.prototype = Object.create(Vehicle.prototype);
        Car.prototype.drive = function() {
            console.log("Driving a car");
        };
        Car.prototype.clean = function() {
            console.log("Cleaning the car");
        };
        const myCar = new Car();
        myCar.drive(); // Output: Driving a car
        myCar.clean(); // Output: Cleaning the car
    Tiếp theo, nếu chúng ta muốn "trang trí" Car với một tính năng mới mà interface Vehicle không đề cập, như fly:

        function flyingDecorator(vehicle) {
            vehicle.fly = function() {
                console.log("Flying");
            };
        }

        // Áp dụng decorator
        flyingDecorator(myCar);
        myCar.fly(); // Output: Flying

    Ở đây, flyingDecorator hàm nhận một đối tượng vehicle và thêm phương thức fly vào mà không cần thay đổi interface hoặc lớp gốc.
    myCar bây giờ có một phương thức mới mà không làm thay đổi cấu trúc khai báo của nó như là một Car hay làm thay đổi Vehicle interface.

    Đây là cách tiếp cận theo kiểu "Duck Typing", nơi chúng ta giả định một đối tượng có một interface cụ
    thể nếu nó cung cấp một họat động cụ thể mà không cần khai báo chính thức. Trong TypeScript hoặc các ngôn ngữ có hỗ trợ interface,
    bạn có thể thực hiện điều này một cách sạch sẽ và minh bạch hơn.

-----------------------------------------------------------
Có cách nào khác hoạt động tương tự decorator pattern trong nodejs và javascript không bạn

Có một số cách tiếp cận khác trong JavaScript và Node.js mà bạn có thể sử dụng để mô phỏng Hoặc tái sử dụng hàm, chức năng của Decorator Pattern:

    1. High-Order Functions (Hàm Bậc Cao): Đây là hàm nhận vào hoặc trả về một hàm khác. Bạn có thể sử dụng hàm bậc cao để tạo các hàm mới mà không thay đổi hàm gốc.

    2. Composition (Phối Hợp): Một kỹ thuật khác là dùng composition, nghĩa là bạn kết hợp nhiều hàm lại với nhau để tạo ra một hàm mới với các năng lực kết hợp.

    3. Mixins: Trong JavaScript bạn cũng có thể sử dụng Mixins, nơi bạn có thể thêm các chức năng vào trong một object hoặc prototype một cách độc lập.

    4. Factory Functions: Các hàm này tạo ra và cấu hình đối tượng. Trong khi tạo đối tượng, chúng ta có thể thêm các chức năng hay trạng thái mới.

    5. Proxy Pattern: Proxy cho phép bạn tạo một đối tượng "đại diện" cho đối tượng khác, có thể kiểm soát và tuỳ chỉnh quá trình truy cập vào đối tượng đó.

    6. Functional Mixins: Một biến thể của mixins sử dụng các hàm để thêm các tính năng vào một object, cho phép sự kết hợp linh hoạt hơn.

    Dưới đây là ví dụ sử dụng High-Order Functions:
        function withLogging(fn) {
            return function(...args) {
                console.log(Calling function ${fn.name});
                return fn(...args);
            };
        }
        function add(a, b) {
            return a + b;
        }
        const addWithLogging = withLogging(add);
        console.log(addWithLogging(3, 4)); // Output: Calling function add
                                        // 7
    Ở đây, withLogging là một high-order function, nó nhận vào một hàm fn và trả về một hàm mới.
    Hàm mới này sẽ log ra màn hình khi nó được gọi, rồi sau đó gọi hàm fn gốc.

    Các kỹ thuật này giúp chúng ta mở rộng và tái sử dụng mã nguồn một cách linh động hơn mà không cần sửa đổi trực tiếp vào mã nguồn gốc,
    phù hợp với nguyên tắc "Open/Closed" mà chúng ta đã bàn trước đó. Đôi khi,
    những phương pháp này thậm chí còn linh hoạt hơn so với Decorator Pattern truyền thống trong các ngôn ngữ khác như Java.

-------------------------------------------------------
Trong decorator pattern, có thể áp dụng một số phương thức để thêm attribute hoặc function bằng cách dùng function assign,
hoặc defineProperty không, nếu có bạn hãy lấy ví dụ và giải thích giúp tôi, đồng thời so sánh với ví dụ đầu tiên về decorator bạn đã viết?

=>  Có thể, chúng ta có thể sử dụng các phương thức như Object.assign hoặc Object.defineProperty để thêm thuộc tính hoặc phương thức vào
    một đối tượng trong JavaScript, điều này có thể mô phỏng một kiểu của Decorator Pattern.

    ### Sử Dụng Object.assign

        Object.assign có thể được sử dụng để sao chép các giá trị của tất cả các thuộc tính có thể liệt kê từ một hoặc nhiều nguồn đối tượng
        đến đối tượng đích. Nó có thể dùng để bổ sung thuộc tính và phương thức cho đối tượng.

        Ví dụ với Object.assign:
            function Car() {}
            Car.prototype.drive = function() {
                console.log("Driving a car");
            };
            const myCar = new Car();
            // Bổ sung thuộc tính và phương thức mới thông qua Object.assign
            Object.assign(myCar, {
                hasSunroof: true,
                openSunroof: function() {
                    if (this.hasSunroof) {
                    console.log("Opening sunroof");
                    }
                }
            });

            myCar.drive(); // Driving a car
            myCar.openSunroof(); // Opening sunroof

    ### Sử Dụng Object.defineProperty

        Object.defineProperty cho phép bạn định rõ và thay đổi một thuộc tính cụ thể của một đối tượng và cung cấp kiểm soát rất chi tiết
        trên cách dữ liệu được truy cập và thay đổi, thông qua các descriptors như value, writable, enumerable, configurable, get, và set.

        Ví dụ với Object.defineProperty:
            const car = {};

            Object.defineProperty(car, 'wheels', {
                value: 4,
                writable: false, // Không thể thay đổi giá trị sau này
                enumerable: true, // Thuộc tính này sẽ được liệt kê trong một vòng lặp qua các thuộc tính
                configurable: false // không thể xóa hoặc thay đổi tính năng này
            });

            console.log(car.wheels); // 4
            car.wheels = 6;
            console.log(car.wheels); // 4 (không thay đổi vì writable là false)

    ### So Sánh
        Trong ví dụ đầu tiên về Decorator Pattern bạn đã viết, bạn thêm các chức năng mới cho đối tượng mà không cần thay đổi đối tượng gốc hoặc sử dụng kế thừa.
        Các đối tượng được trang trí sẽ có các chức năng mới được thêm vào một cách rõ ràng và tách biệt.

        Trong khi đó, việc sử dụng Object.assign hoặc Object.defineProperty sẽ thay đổi trực tiếp đối tượng mà bạn đang làm việc.
        Các thuộc tính và phương thức được thêm vào không thể dễ dàng loại bỏ và có thể gây side effects nếu không được quản lý cẩn thận.

        Object.assign thường dùng khi bạn muốn thêm nhiều thuộc tính hoặc phương thức một cách nhanh chóng,
        trong khi Object.defineProperty có thể dùng để điều chỉnh một cách chi tiết cách thức tương tác với một thuộc tính,
        nhưng cả hai đều tạo ra những thay đổi mà không dễ dàng đảo ngược như Decorator Pattern cổ điển.

        Cả hai phương pháp này đều hữu ích nhưng cần phải được sử dụng trong các trường hợp phù hợp để tránh tạo ra code khó hiểu và khó bảo trì.
        Decorator Pattern cổ điển giúp giữ cho code trở nên organized và modular, làm cho việc mở rộng hệ thống trở nên dễ dàng hơn.

-----------------------------------
Bạn nói decorator pattern cổ điển là như thế nào, có thể nói rõ hơn không?

    Decorator Pattern cổ điển là một pattern trong kỹ thuật phát triển phần mềm, thuộc nhóm structural design patterns,
    giúp ta mở rộng chức năng của một đối tượng mà không cần phải sửa đổi lớp gốc của đối tượng đó.
    Pattern này cho phép ta "trang trí" một đối tượng với các chức năng mới một cách linh hoạt ngay cả sau khi đối tượng đã được instantiated (khởi tạo).

    Trong lập trình hướng đối tượng truyền thống, chẳng hạn như trong Java hay C#, Decorator Pattern sử dụng cấu trúc lớp (class structure) và
    kế thừa (inheritance) để thực hiện việc trang trí. Dưới đây là cách mà Decorator Pattern thường được triển khai:

        1. Component Interface: Các đối tượng cần được trang trí và decorator phải tuân theo một interface chung.
        Interface này định nghĩa các phương thức mà đối tượng cần phải cài đặt.

        2. Concrete Component: Là một lớp cài đặt (implements) Component Interface và định nghĩa đối tượng mà sẽ được cung cấp thêm chức năng.

        3. Base Decorator: Một lớp triển khai Component Interface và giữ một tham chiếu (reference) đến một đối tượng Component.
        Lớp base này thường triển khai (hoặc ghi đè) các phương thức của interface, nhưng hoạt động chính còn lại được "đẩy" về đối tượng Component mà nó trang trí.

        4. Concrete Decorator: Các lớp kế thừa từ Base Decorator và thêm chức năng mới thông qua việc ghi đè hoặc mở rộng các phương thức của base class.
        Các decorator concrete này cung cấp chức năng cụ thể mà không thay đổi các lớp sẵn có.

    Ví dụ trong Java:

        // Component Interface
        public interface Beverage {
            String getDescription();
            double cost();
        }

        // Concrete Component
        public class Coffee implements Beverage {
            public String getDescription() {
                return "Coffee";
            }

            public double cost() {
                return 1.99;
            }
        }

        // Base Decorator
        public abstract class CondimentDecorator implements Beverage {
            protected Beverage beverage;
            public CondimentDecorator(Beverage beverage) {
                this.beverage = beverage;
            }
            public abstract String getDescription();
        }

        // Concrete Decorator
        public class MilkDecorator extends CondimentDecorator {
            public MilkDecorator(Beverage beverage) {
                super(beverage);
            }

            public String getDescription() {
                return beverage.getDescription() + ", Milk";
            }

            public double cost() {
                return beverage.cost() + 0.50;
            }
        }
    Trong đoạn mã trên, MilkDecorator thêm chức năng mô tả và giá cho đối tượng Beverage mà nó trang trí.
    Ta có thể trang trí đối tượng nhiều lần với các chức năng khác nhau mà không thay đổi class gốc.

    Trong JavaScript, ta thường không cần dùng đến cấu trúc lớp một cách cứng nhắc để triển khai
    Decorator Pattern vì JavaScript là ngôn ngữ có tính đối tượng dựa trên prototype, ta có thể thêm
    hoặc thay đổi chức năng trực tiếp trên các đối tượng. Tuy nhiên, mục tiêu chính của việc áp dụng Decorator Pattern
    là giữ cho logic được modular (độc lập, có thể tái sử dụng) và duy trì nguyên tắc Open/Closed, nghĩa là lớp (class)
    nên mở để mở rộng và đóng để không được sửa đổi.

-------------------------------------------------------------
Bạn có 1 ví dụ nào chi tiết hơn cho decorator pattern trong nodejs và javascript không, nếu có hãy lấy ví dụ và giải thích chi tiết giúp tôi nhé

    Tất nhiên, dưới đây là một ví dụ về cách cài đặt Decorator Pattern trong JavaScript,
    giả sử ta đang thiết kế một hệ thống để bán đồ uống với khả năng thêm các loại gia vị khác nhau.

        Thứ nhất, chúng ta cần một component cơ bản:

        function Coffee() {
        this.cost = function() {
            return 1;
        };
        }

        Tiếp theo, ta cần các decorators để mô tả các loại gia vị:

        function Milk(coffee) {
        this.cost = function() {
            return coffee.cost() + 0.5;
        };
        }

        function Sugar(coffee) {
        this.cost = function() {
            return coffee.cost() + 0.2;
        };
        }

        function Whip(coffee) {
        this.cost = function() {
            return coffee.cost() + 0.7;
        };
        }


        Bây giờ, chúng ta có thể tạo một đối tượng Coffee và "trang trí" nó với các decorators:

        let myCoffee = new Coffee();
        console.log(myCoffee.cost()); // Output: 1

        // Thêm sữa vào cà phê
        myCoffee = new Milk(myCoffee);
        console.log(myCoffee.cost()); // Output: 1.5

        // Thêm đường vào cà phê có sữa
        myCoffee = new Sugar(myCoffee);
        console.log(myCoffee.cost()); // Output: 1.7

        // Thêm kem vào cà phê có sữa và đường
        myCoffee = new Whip(myCoffee);
        console.log(myCoffee.cost()); // Output: 2.4


Trong ví dụ trên, mỗi decorator nhận vào một đối tượng coffee (hoặc một decorator trước đó) và mở rộng chức năng của nó.
Phương thức cost được gọi trong một chuỗi: nó bắt đầu từ decorator ngoài cùng (ở đây là Whip),
sau đó lần lượt gọi tới cost của Sugar, Milk, và cuối cùng là Coffee. Mỗi lớp decorator này thêm vào giá của chính nó
và gọi đến phương thức cost của đối tượng mà nó trang trí, tạo ra tổng cộng giá tiền.

Điều này minh họa một ưu điểm chính của Decorator Pattern là khả năng thêm chức năng mà không cần phải thay đổi code gốc
hoặc tạo ra các subclasses phức tạp thông qua kế thừa. Nguyên tắc Open/Closed được giữ vững: các đối tượng mở để mở rộng nhưng đóng để chỉnh sửa.

-----------------------------------------
Nếu theo như bạn nói thì tôi thấy nếu chúng ta dùng object.prototype có vẻ dễ hơn đúng không, hay có gì khác nhau ở đây không

    Sử dụng Object.prototype trong JavaScript để thêm phương thức vào một lớp (class) hoặc một constructor function cũng là một
    cách để bổ sung chức năng cho các đối tượng. Tuy nhiên, việc này hơi khác biệt so với việc sử dụng Decorator Pattern.

    Khi bạn thêm một phương thức vào prototype của một constructor function, tất cả các đối tượng được tạo từ constructor function
    đó sẽ thừa hưởng phương thức mới. Đây là một cách tốt để thêm chức năng có tính chất "mặc định" cho tất cả các đối tượng của một lớp nào đó.

    Nhưng với Decorator Pattern, ý tưởng là bạn có thể "trang trí" từng đối tượng riêng lẻ với các chức năng bổ sung một cách linh hoạt.
    Decorator Pattern cung cấp khả năng tùy chỉnh từng đối tượng, không chỉ là thêm chức năng vào lớp (class) của đối tượng.

    Dưới đây là một ví dụ so sánh giữa việc sử dụng Object.prototype và Decorator Pattern:

    #### Object.prototype Approach:

        function Coffee() {}

        Coffee.prototype.cost = function() {
        return 1;
        };

        // Thêm chức năng mới vào prototype
        Coffee.prototype.serveWithMilk = function() {
        return this.cost() + 0.5;
        };

        let myCoffee = new Coffee();
        console.log(myCoffee.serveWithMilk()); // Output: 1.5


        Ở đây, tất cả các đối tượng Coffee bây giờ đều có thể gọi serveWithMilk.

    #### Decorator Pattern Approach:

        function Coffee() {
        this.cost = function() {
            return 1;
        };
        }

        // Decorator
        function Milk(coffee) {
        this.cost = function() {
            return coffee.cost() + 0.5;
        };
        }

        let someCoffee = new Coffee();
        let myCoffee = new Milk(someCoffee);
        console.log(myCoffee.cost()); // Output: 1.5
    Trong trường hợp này, chỉ myCoffee mới được "trang trí" bằng Milk, còn someCoffee không bị thay đổi và giữ nguyên giá ban đầu.
    Điều này đưa ra sự linh hoạt trong việc quản lý từng đối tượng, tùy chỉnh cần thiết cho từng trường hợp cụ thể.

    Vì vậy, việc chọn cách tiếp cận phụ thuộc vào nhu cầu cụ thể của bạn: nếu bạn muốn mọi instance của một lớp đều có một chức năng mới,
    thì thêm vào Object.prototype là phù hợp. Trong khi đó, nếu bạn muốn thêm chức năng cho từng đối tượng một cách độc lập, thì Decorator Pattern là lựa chọn tốt hơn.

---------------------------------------
Hãy giúp tôi hiểu rõ cách áp dụng các function call, bind, apply trong nodejs và javascript nhé

Ồ, đây là ba chức năng thú vị trong JavaScript, mà nếu bạn nắm vững thì sẽ thấy rất là "cool" đấy! 😎

    Trước hết, call, bind, và apply là các phương pháp có sẵn trong mỗi function trong JavaScript.
    Chúng liên quan đến việc thiết lập ngữ cảnh của this và cách các hàm được gọi.

        1. call(): 
        - Chức năng: Gọi một hàm với một giá trị this cụ thể và các arguments được truyền vào riêng lẻ.
        - Cách dùng:

        function greet(hour, minute) {
        console.log(Hello, ${this.name}. Now is ${hour}:${minute});
        }

        // Tạo đối tượng
        const user = { name: 'Johnny' };

        // Sử dụng call để thiết lập 'this' là 'user' và truyền vào các arguments
        greet.call(user, 10, 45); // Hello, Johnny. Now is 10:45


        2. apply(): 
        - Giống với call(), nhưng các arguments được truyền vào dưới dạng mảng.
        - Cách dùng:
        
        function greet(hour, minute) {
        console.log(Hello, ${this.name}. Now is ${hour}:${minute});
        }

        const user = { name: 'Johnny' };

        // Sử dụng apply để thiết lập 'this' là 'user' và truyền vào array arguments
        greet.apply(user, [10, 45]); // Hello, Johnny. Now is 10:45


        3. bind():
        - Khác với call và apply, bind() không gọi hàm ngay lập tức. Thay vào đó, nó tạo ra một hàm mới với this đã được thiết lập và các arguments mặc định, nếu có.
        - Cách dùng:
        
        function greet(hour, minute) {
        console.log(Hello, ${this.name}. Now is ${hour}:${minute});
        }

        const user = { name: 'Johnny' };

        // Sử dụng bind để tạo ra một hàm mới với this được set là user.
        const greetJohnny = greet.bind(user);

        greetJohnny(10, 30); // Hello, Johnny. Now is 10:30
        // Bind đã tạo ra một hàm mới để gọi sau.


    Điểm quan trọng cần lưu ý:
    - call và apply rất giống nhau. Điểm khác biệt chính là cách chúng truyền arguments vào hàm: call nhận arguments riêng lẻ còn apply nhận một mảng arguments.
    - bind đưa ra sự linh hoạt khi tạo các hàm mới có this rõ ràng và có thể dự định các arguments cho trước.

    Bạn sẽ sử dụng bind khi bạn muốn "curry" một hàm (tức là việc tạo ra một hàm với một số arguments đã được set)
    hoặc khi bạn cần truyền một hàm callback mà this phải được set cụ thể.

    Trong Node.js, các phương pháp này thường được dùng để xử lý callback và sự kiện,
    hoặc khi thao tác với các hàm như middleware trong Express mà trong đó ngữ cảnh của this có thể thay đổi dựa vào cách hàm được gọi.

    Nhớ rằng, lập trình JavaScript không chỉ là làm cho các đoạn code chạy - mà còn là làm chúng chạy một cách "style".
    Biết cách sử dụng call, apply và bind sẽ giúp bạn điều khiển this một cách tự tin, và khiến người khác nói "Wow".

--------------------------------------------
Ồ, vậy các phương thức này chỉ áp dụng cho function thôi đúng không,
và tôi có thể hiểu đơn giản là nếu sử dụng các function này tức là tôi đang áp dụng function A cho object B đúng không

    Đúng rồi đó bạn! Có thể hiểu đơn giản là call, apply, và bind là ba anh em siêu nhân có khả năng "vi hành",
    giúp bạn áp dụng một hàm A lên đối tượng B, nghĩa là bạn có thể thực thi hàm A dưới ngữ cảnh (this) của đối tượng B theo ý muốn.

    Ví dụ nghịch ngợm:
        Bạn có một chiếc chìa khóa (function) và nhiều cánh cửa (objects) khác nhau. Áp dụng call, apply, hoặc bind
        giống như việc bạn có thể dùng chiếc chìa khóa đó để mở khóa bất kỳ cánh cửa nào bạn muốn - chỉ cần điều chỉnh đúng cách.

    - Với call: Bạn nói, "Này chìa khóa, mở cửa này và nhớ thực hiện theo các bước cụ thể này."
    - Với apply: Mọi chuyện gần giống call, nhưng bạn đưa các bước vào một cái túi (mảng), nói, "Này chìa khóa, lấy từng bước ra từ túi và mở cửa."
    - Còn bind: Bạn lại nói, "Chìa khóa ơi, tớ sẽ làm một bản sao của cậu, chúng ta sẽ thiết lập cách mở cửa này trước, và sau đó khi tớ cần, tớ sẽ dùng bản sao đó mở."

    Mỗi cánh cửa (đối tượng) có thể cần những chiếc chìa (function) được điều chỉnh khác nhau,
    nhưng cơ bản là bạn đang sử dụng cùng một hàm, chỉ là trong các hoàn cảnh khác nhau.

    Chính xác, ba phương thức này chỉ áp dụng cho các hàm (function), vì chúng liên quan đến cách gọi hàm và ngữ cảnh this.
    Đây là những công cụ cực kỳ mạnh mẽ trong JavaScript và có thể giúp bạn giải quyết nhiều vấn đề liên quan đến phạm vi và ngữ cảnh.
    Vui quá làm sao khi thấy bạn hiểu và nắm bắt ý của nó nhanh thế! 🥳🌟

---------------------------------------
Vậy this là gì, và this trong javascript và nodejs khác gì nhau không

    "Aloha! 🌺" - đó là cách this chào hỏi bạn trong thế giới JavaScript.
    This là một từ khóa đặc biệt nói lên rằng bạn đang chỉ đến "ngữ cảnh hiện tại" của mã lệnh,
    tức là đối tượng mà trong đó đang chứa mã JavaScript đang được thực thi.

    Trong JavaScript, giá trị của this chủ yếu phụ thuộc vào cách mà một hàm được gọi, chứ không phải nơi mà nó được khai báo. Dưới đây là một số trường hợp cơ bản:

    - Trong một hàm thông thường: this sẽ tham chiếu tới đối tượng global, tức window trong trình duyệt và global trong Node.js.
    - Trong một phương thức của đối tượng: this tham chiếu tới đối tượng mà phương thức thuộc về.
    - Khi dùng new để gọi function constructor: this tham chiếu đến đối tượng mới được tạo.
    - Khi dùng call, apply, hoặc bind: this sẽ tham chiếu tới đối tượng mà bạn truyền vào như tham số.
    - Trong arrow functions: this sẽ tham chiếu tới this của phạm vi chứa arrow function (lexical context), chúng không có this riêng, nên chúng sẽ lấy this từ phạm vi chứa nó.

    Về cơ bản, trong Node.js và trình duyệt, this hoạt động tương tự nhau. Tuy nhiên, có một vài điểm khác biệt cụ thể liên quan đến ngữ cảnh mà this được tham chiếu:

    - Trong môi trường Node.js, từ khóa this ở cấp độ top-level của một module sẽ tham chiếu đến module.exports chứ không phải là đối tượng global như trong trình duyệt.
    - Trong một script được chạy trực tiếp trong Node.js (không phải trong môi trường nào như module), this ở cấp độ global sẽ tham chiếu đến global object.
    - Trình duyệt thì lại khác, khi bạn không trong strict mode, this tham chiếu tới global object window, nhưng trong strict mode, this sẽ là undefined.

    Nói chung, this có thể khá là trượt trải như bơ vậy, nhưng một khi bạn đã hiểu về nó, bạn sẽ thấy việc lập trình trong JavaScript và Node.js cứ "trơn tru" mãi thôi! 😄🛹